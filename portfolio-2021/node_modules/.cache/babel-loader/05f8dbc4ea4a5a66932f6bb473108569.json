{"ast":null,"code":"const {\n  inflateRawSync\n} = require('zlib');\n\nconst base64url = require('../help/base64url');\n\nconst getKey = require('../help/get_key');\n\nconst {\n  KeyStore\n} = require('../jwks');\n\nconst errors = require('../errors');\n\nconst {\n  check,\n  decrypt,\n  keyManagementDecrypt\n} = require('../jwa');\n\nconst JWK = require('../jwk');\n\nconst {\n  createSecretKey\n} = require('../help/key_object');\n\nconst generateCEK = require('./generate_cek');\n\nconst validateHeaders = require('./validate_headers');\n\nconst {\n  detect: resolveSerialization\n} = require('./serializers');\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot);\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s;\n  const apu = prot.apu || unprotected.apu || header.apu;\n  const apv = prot.apv || unprotected.apv || header.apv;\n  const iv = prot.iv || unprotected.iv || header.iv;\n  const tag = prot.tag || unprotected.tag || header.tag;\n  return { ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? {\n      p2s: base64url.decodeToBuffer(p2s)\n    } : undefined),\n    ...(typeof apu === 'string' ? {\n      apu: base64url.decodeToBuffer(apu)\n    } : undefined),\n    ...(typeof apv === 'string' ? {\n      apv: base64url.decodeToBuffer(apv)\n    } : undefined),\n    ...(typeof iv === 'string' ? {\n      iv: base64url.decodeToBuffer(iv)\n    } : undefined),\n    ...(typeof tag === 'string' ? {\n      tag: base64url.decodeToBuffer(tag)\n    } : undefined)\n  };\n};\n/*\n * @public\n */\n\n\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, {\n  crit = [],\n  complete = false,\n  algorithms\n} = {}) => {\n  key = getKey(key, true);\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe);\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened';\n    const {\n      recipients,\n      ...root\n    } = jwe;\n    jwe = { ...root,\n      ...recipients[0]\n    };\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      [prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.');\n    } else {\n      // flattened serialization format\n      ({\n        protected: prot,\n        encrypted_key: encryptedKey,\n        iv,\n        ciphertext,\n        tag,\n        unprotected,\n        aad,\n        header\n      } = jwe);\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{\n        header\n      }], true, crit);\n    }\n\n    opts = combineHeader(prot, unprotected, header);\n    ({\n      alg,\n      enc\n    } = opts);\n\n    if (algorithms && !algorithms.has(alg === 'dir' ? enc : alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      let keys;\n\n      if (opts.alg === 'dir') {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.enc,\n          key_ops: ['decrypt']\n        });\n      } else {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.alg,\n          key_ops: ['unwrapKey']\n        });\n      }\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            const errs = [];\n\n            for (const key of keys) {\n              try {\n                return jweDecrypt(true, serialization, jwe, key, {\n                  crit,\n                  complete,\n                  algorithms: algorithms ? [...algorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n\n            const multi = new errors.JOSEMultiError(errs);\n\n            if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n              throw new errors.JWEDecryptionFailed();\n            }\n\n            throw multi;\n          }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]));\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, {\n          alg: enc,\n          use: 'enc'\n        });\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc);\n    }\n\n    let adata;\n\n    if (aad) {\n      adata = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.from(aad)]);\n    } else {\n      adata = Buffer.from(prot || '');\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv);\n    } catch (err) {}\n\n    try {\n      tag = base64url.decodeToBuffer(tag);\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), {\n      iv,\n      tag,\n      aad: adata\n    });\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext);\n    }\n\n    if (complete) {\n      const result = {\n        cleartext,\n        key,\n        cek\n      };\n      if (aad) result.aad = aad;\n      if (header) result.header = header;\n      if (unprotected) result.unprotected = unprotected;\n      if (prot) result.protected = base64url.JSON.decode(prot);\n      return result;\n    }\n\n    return cleartext;\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({\n    header\n  }) => ({\n    header\n  })), true, crit); // general serialization format\n\n  const {\n    recipients,\n    ...root\n  } = jwe;\n  const errs = [];\n\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        algorithms: algorithms ? [...algorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs);\n\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined);","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/jose/lib/jwe/decrypt.js"],"names":["inflateRawSync","require","base64url","getKey","KeyStore","errors","check","decrypt","keyManagementDecrypt","JWK","createSecretKey","generateCEK","validateHeaders","detect","resolveSerialization","SINGLE_RECIPIENT","Set","combineHeader","prot","unprotected","header","JSON","decode","p2s","apu","apv","iv","tag","decodeToBuffer","undefined","jweDecrypt","skipValidateHeaders","serialization","jwe","key","crit","complete","algorithms","Array","isArray","some","s","TypeError","alg","ciphertext","enc","encryptedKey","opts","cek","aad","recipients","length","root","has","split","protected","encrypted_key","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","err","push","multi","JOSEMultiError","e","JWEDecryptionFailed","asKey","use","unwrapped","adata","Buffer","concat","from","cleartext","zip","result","map","recipient","every","module","exports","bind"],"mappings":"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","sourcesContent":["const { inflateRawSync } = require('zlib')\n\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, decrypt, keyManagementDecrypt } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { createSecretKey } = require('../help/key_object')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\nconst { detect: resolveSerialization } = require('./serializers')\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened'])\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot)\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s\n  const apu = prot.apu || unprotected.apu || header.apu\n  const apv = prot.apv || unprotected.apv || header.apv\n  const iv = prot.iv || unprotected.iv || header.iv\n  const tag = prot.tag || unprotected.tag || header.tag\n\n  return {\n    ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? { p2s: base64url.decodeToBuffer(p2s) } : undefined),\n    ...(typeof apu === 'string' ? { apu: base64url.decodeToBuffer(apu) } : undefined),\n    ...(typeof apv === 'string' ? { apv: base64url.decodeToBuffer(apv) } : undefined),\n    ...(typeof iv === 'string' ? { iv: base64url.decodeToBuffer(iv) } : undefined),\n    ...(typeof tag === 'string' ? { tag: base64url.decodeToBuffer(tag) } : undefined)\n  }\n}\n\n/*\n * @public\n */\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, { crit = [], complete = false, algorithms } = {}) => {\n  key = getKey(key, true)\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings')\n  } else if (algorithms) {\n    algorithms = new Set(algorithms)\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe)\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened'\n    const { recipients, ...root } = jwe\n    jwe = { ...root, ...recipients[0] }\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') { // compact serialization format\n      ([prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.'))\n    } else { // flattened serialization format\n      ({ protected: prot, encrypted_key: encryptedKey, iv, ciphertext, tag, unprotected, aad, header } = jwe)\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{ header }], true, crit)\n    }\n\n    opts = combineHeader(prot, unprotected, header)\n\n    ;({ alg, enc } = opts)\n\n    if (algorithms && !algorithms.has(alg === 'dir' ? enc : alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      let keys\n      if (opts.alg === 'dir') {\n        keys = keystore.all({ kid: opts.kid, alg: opts.enc, key_ops: ['decrypt'] })\n      } else {\n        keys = keystore.all({ kid: opts.kid, alg: opts.alg, key_ops: ['unwrapKey'] })\n      }\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jweDecrypt(true, serialization, jwe, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n            throw new errors.JWEDecryptionFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]))\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, { alg: enc, use: 'enc' })\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc)\n    }\n\n    let adata\n    if (aad) {\n      adata = Buffer.concat([\n        Buffer.from(prot || ''),\n        Buffer.from('.'),\n        Buffer.from(aad)\n      ])\n    } else {\n      adata = Buffer.from(prot || '')\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv)\n    } catch (err) {}\n    try {\n      tag = base64url.decodeToBuffer(tag)\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), { iv, tag, aad: adata })\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext)\n    }\n\n    if (complete) {\n      const result = { cleartext, key, cek }\n      if (aad) result.aad = aad\n      if (header) result.header = header\n      if (unprotected) result.unprotected = unprotected\n      if (prot) result.protected = base64url.JSON.decode(prot)\n      return result\n    }\n\n    return cleartext\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({ header }) => ({ header })), true, crit)\n\n  // general serialization format\n  const { recipients, ...root } = jwe\n  const errs = []\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root, ...recipient }, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined)\n"]},"metadata":{},"sourceType":"script"}