{"ast":null,"code":"const isObject = require('../help/is_object');\n\nconst epoch = require('../help/epoch');\n\nconst secs = require('../help/secs');\n\nconst getKey = require('../help/get_key');\n\nconst {\n  bare: verify\n} = require('../jws/verify');\n\nconst {\n  JWTClaimInvalid,\n  JWTExpired\n} = require('../errors');\n\nconst {\n  isString,\n  isNotString\n} = require('./shared_validations');\n\nconst decode = require('./decode');\n\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid);\nconst isOptionString = isString.bind(undefined, TypeError);\nconst IDTOKEN = 'id_token';\nconst LOGOUTTOKEN = 'logout_token';\nconst ATJWT = 'at+JWT';\n\nconst isTimestamp = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(`\"${label}\" claim is missing`, label, 'missing');\n  }\n\n  if (value !== undefined && typeof value !== 'number') {\n    throw new JWTClaimInvalid(`\"${label}\" claim must be a JSON numeric value`, label, 'invalid');\n  }\n};\n\nconst isStringOrArrayOfStrings = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(`\"${label}\" claim is missing`, label, 'missing');\n  }\n\n  if (value !== undefined && isNotString(value) && isNotArrayOfStrings(value)) {\n    throw new JWTClaimInvalid(`\"${label}\" claim must be a string or array of strings`, label, 'invalid');\n  }\n};\n\nconst isNotArrayOfStrings = val => !Array.isArray(val) || val.length === 0 || val.some(isNotString);\n\nconst normalizeTyp = value => value.toLowerCase().replace(/^application\\//, '');\n\nconst validateOptions = ({\n  algorithms,\n  audience,\n  clockTolerance,\n  complete = false,\n  crit,\n  ignoreExp = false,\n  ignoreIat = false,\n  ignoreNbf = false,\n  issuer,\n  jti,\n  maxAuthAge,\n  maxTokenAge,\n  nonce,\n  now = new Date(),\n  profile,\n  subject,\n  typ\n}) => {\n  isOptionString(profile, 'options.profile');\n\n  if (typeof complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean');\n  }\n\n  if (typeof ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean');\n  }\n\n  if (typeof ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean');\n  }\n\n  if (typeof ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean');\n  }\n\n  isOptionString(maxTokenAge, 'options.maxTokenAge');\n  isOptionString(subject, 'options.subject');\n  isOptionString(maxAuthAge, 'options.maxAuthAge');\n  isOptionString(jti, 'options.jti');\n  isOptionString(clockTolerance, 'options.clockTolerance');\n  isOptionString(typ, 'options.typ');\n\n  if (issuer !== undefined && isNotString(issuer) && isNotArrayOfStrings(issuer)) {\n    throw new TypeError('options.issuer must be a string or an array of strings');\n  }\n\n  if (audience !== undefined && isNotString(audience) && isNotArrayOfStrings(audience)) {\n    throw new TypeError('options.audience must be a string or an array of strings');\n  }\n\n  if (algorithms !== undefined && isNotArrayOfStrings(algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings');\n  }\n\n  isOptionString(nonce, 'options.nonce');\n\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object');\n  }\n\n  if (ignoreIat && maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together');\n  }\n\n  if (crit !== undefined && isNotArrayOfStrings(crit)) {\n    throw new TypeError('options.crit must be an array of strings');\n  }\n\n  switch (profile) {\n    case IDTOKEN:\n      if (!issuer) {\n        throw new TypeError('\"issuer\" option is required to validate an ID Token');\n      }\n\n      if (!audience) {\n        throw new TypeError('\"audience\" option is required to validate an ID Token');\n      }\n\n      break;\n\n    case ATJWT:\n      if (!issuer) {\n        throw new TypeError('\"issuer\" option is required to validate a JWT Access Token');\n      }\n\n      if (!audience) {\n        throw new TypeError('\"audience\" option is required to validate a JWT Access Token');\n      }\n\n      typ = ATJWT;\n      break;\n\n    case LOGOUTTOKEN:\n      if (!issuer) {\n        throw new TypeError('\"issuer\" option is required to validate a Logout Token');\n      }\n\n      if (!audience) {\n        throw new TypeError('\"audience\" option is required to validate a Logout Token');\n      }\n\n      break;\n\n    case undefined:\n      break;\n\n    default:\n      throw new TypeError(`unsupported options.profile value \"${profile}\"`);\n  }\n\n  return {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxAuthAge,\n    maxTokenAge,\n    nonce,\n    now,\n    profile,\n    subject,\n    typ\n  };\n};\n\nconst validateTypes = ({\n  header,\n  payload\n}, profile, options) => {\n  isPayloadString(header.alg, '\"alg\" header parameter', 'alg', true);\n  isTimestamp(payload.iat, 'iat', profile === IDTOKEN || profile === LOGOUTTOKEN || profile === ATJWT || !!options.maxTokenAge);\n  isTimestamp(payload.exp, 'exp', profile === IDTOKEN || profile === ATJWT);\n  isTimestamp(payload.auth_time, 'auth_time', !!options.maxAuthAge);\n  isTimestamp(payload.nbf, 'nbf');\n  isPayloadString(payload.jti, '\"jti\" claim', 'jti', profile === LOGOUTTOKEN || profile === ATJWT || !!options.jti);\n  isPayloadString(payload.acr, '\"acr\" claim', 'acr');\n  isPayloadString(payload.nonce, '\"nonce\" claim', 'nonce', !!options.nonce);\n  isStringOrArrayOfStrings(payload.iss, 'iss', !!options.issuer);\n  isPayloadString(payload.sub, '\"sub\" claim', 'sub', profile === IDTOKEN || profile === ATJWT || !!options.subject);\n  isStringOrArrayOfStrings(payload.aud, 'aud', !!options.audience);\n  isPayloadString(payload.azp, '\"azp\" claim', 'azp', profile === IDTOKEN && Array.isArray(payload.aud) && payload.aud.length > 1);\n  isStringOrArrayOfStrings(payload.amr, 'amr');\n  isPayloadString(header.typ, '\"typ\" header parameter', 'typ', !!options.typ);\n\n  if (profile === ATJWT) {\n    isPayloadString(payload.client_id, '\"client_id\" claim', 'client_id', true);\n  }\n\n  if (profile === LOGOUTTOKEN) {\n    isPayloadString(payload.sid, '\"sid\" claim', 'sid');\n\n    if (!('sid' in payload) && !('sub' in payload)) {\n      throw new JWTClaimInvalid('either \"sid\" or \"sub\" (or both) claims must be present');\n    }\n\n    if ('nonce' in payload) {\n      throw new JWTClaimInvalid('\"nonce\" claim is prohibited', 'nonce', 'prohibited');\n    }\n\n    if (!('events' in payload)) {\n      throw new JWTClaimInvalid('\"events\" claim is missing', 'events', 'missing');\n    }\n\n    if (!isObject(payload.events)) {\n      throw new JWTClaimInvalid('\"events\" claim must be an object', 'events', 'invalid');\n    }\n\n    if (!('http://schemas.openid.net/event/backchannel-logout' in payload.events)) {\n      throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim', 'events', 'invalid');\n    }\n\n    if (!isObject(payload.events['http://schemas.openid.net/event/backchannel-logout'])) {\n      throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object', 'events', 'invalid');\n    }\n  }\n};\n\nconst checkAudiencePresence = (audPayload, audOption, profile) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  } // Each principal intended to process the JWT MUST\n  // identify itself with a value in the audience claim\n\n\n  audPayload = new Set(audPayload);\n  return audOption.some(Set.prototype.has.bind(audPayload));\n};\n\nmodule.exports = (token, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  const {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxAuthAge,\n    maxTokenAge,\n    nonce,\n    now,\n    profile,\n    subject,\n    typ\n  } = options = validateOptions(options);\n  const decoded = decode(token, {\n    complete: true\n  });\n  key = getKey(key, true);\n\n  if (complete) {\n    ({\n      key\n    } = verify(true, 'preparsed', {\n      decoded,\n      token\n    }, key, {\n      crit,\n      algorithms,\n      complete: true\n    }));\n    decoded.key = key;\n  } else {\n    verify(true, 'preparsed', {\n      decoded,\n      token\n    }, key, {\n      crit,\n      algorithms\n    });\n  }\n\n  const unix = epoch(now);\n  validateTypes(decoded, profile, options);\n\n  if (issuer && (typeof decoded.payload.iss !== 'string' || !(typeof issuer === 'string' ? [issuer] : issuer).includes(decoded.payload.iss))) {\n    throw new JWTClaimInvalid('unexpected \"iss\" claim value', 'iss', 'check_failed');\n  }\n\n  if (nonce && decoded.payload.nonce !== nonce) {\n    throw new JWTClaimInvalid('unexpected \"nonce\" claim value', 'nonce', 'check_failed');\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('unexpected \"sub\" claim value', 'sub', 'check_failed');\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('unexpected \"jti\" claim value', 'jti', 'check_failed');\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience, profile)) {\n    throw new JWTClaimInvalid('unexpected \"aud\" claim value', 'aud', 'check_failed');\n  }\n\n  if (typ && normalizeTyp(decoded.header.typ) !== normalizeTyp(typ)) {\n    throw new JWTClaimInvalid('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n  }\n\n  const tolerance = clockTolerance ? secs(clockTolerance) : 0;\n\n  if (maxAuthAge) {\n    const maxAuthAgeSeconds = secs(maxAuthAge);\n\n    if (decoded.payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n      throw new JWTClaimInvalid('\"auth_time\" claim timestamp check failed (too much time has elapsed since the last End-User authentication)', 'auth_time', 'check_failed');\n    }\n  }\n\n  if (!ignoreIat && !('exp' in decoded.payload) && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n  }\n\n  if (maxTokenAge) {\n    const age = unix - decoded.payload.iat;\n    const max = secs(maxTokenAge);\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n    }\n  }\n\n  if (profile === IDTOKEN && Array.isArray(decoded.payload.aud) && decoded.payload.aud.length > 1 && decoded.payload.azp !== audience) {\n    throw new JWTClaimInvalid('unexpected \"azp\" claim value', 'azp', 'check_failed');\n  }\n\n  return complete ? decoded : decoded.payload;\n};","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/jose/lib/jwt/verify.js"],"names":["isObject","require","epoch","secs","getKey","bare","verify","JWTClaimInvalid","JWTExpired","isString","isNotString","decode","isPayloadString","bind","undefined","isOptionString","TypeError","IDTOKEN","LOGOUTTOKEN","ATJWT","isTimestamp","value","label","required","isStringOrArrayOfStrings","isNotArrayOfStrings","val","Array","isArray","length","some","normalizeTyp","toLowerCase","replace","validateOptions","algorithms","audience","clockTolerance","complete","crit","ignoreExp","ignoreIat","ignoreNbf","issuer","jti","maxAuthAge","maxTokenAge","nonce","now","Date","profile","subject","typ","getTime","validateTypes","header","payload","options","alg","iat","exp","auth_time","nbf","acr","iss","sub","aud","azp","amr","client_id","sid","events","checkAudiencePresence","audPayload","audOption","includes","Set","prototype","has","module","exports","token","key","decoded","unix","tolerance","maxAuthAgeSeconds","age","max"],"mappings":"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","sourcesContent":["const isObject = require('../help/is_object')\nconst epoch = require('../help/epoch')\nconst secs = require('../help/secs')\nconst getKey = require('../help/get_key')\nconst { bare: verify } = require('../jws/verify')\nconst { JWTClaimInvalid, JWTExpired } = require('../errors')\n\nconst { isString, isNotString } = require('./shared_validations')\nconst decode = require('./decode')\n\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid)\nconst isOptionString = isString.bind(undefined, TypeError)\n\nconst IDTOKEN = 'id_token'\nconst LOGOUTTOKEN = 'logout_token'\nconst ATJWT = 'at+JWT'\n\nconst isTimestamp = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(`\"${label}\" claim is missing`, label, 'missing')\n  }\n\n  if (value !== undefined && (typeof value !== 'number')) {\n    throw new JWTClaimInvalid(`\"${label}\" claim must be a JSON numeric value`, label, 'invalid')\n  }\n}\n\nconst isStringOrArrayOfStrings = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(`\"${label}\" claim is missing`, label, 'missing')\n  }\n\n  if (value !== undefined && (isNotString(value) && isNotArrayOfStrings(value))) {\n    throw new JWTClaimInvalid(`\"${label}\" claim must be a string or array of strings`, label, 'invalid')\n  }\n}\n\nconst isNotArrayOfStrings = val => !Array.isArray(val) || val.length === 0 || val.some(isNotString)\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '')\n\nconst validateOptions = ({\n  algorithms, audience, clockTolerance, complete = false, crit, ignoreExp = false,\n  ignoreIat = false, ignoreNbf = false, issuer, jti, maxAuthAge, maxTokenAge, nonce, now = new Date(),\n  profile, subject, typ\n}) => {\n  isOptionString(profile, 'options.profile')\n\n  if (typeof complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean')\n  }\n\n  if (typeof ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean')\n  }\n\n  if (typeof ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean')\n  }\n\n  if (typeof ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean')\n  }\n\n  isOptionString(maxTokenAge, 'options.maxTokenAge')\n  isOptionString(subject, 'options.subject')\n  isOptionString(maxAuthAge, 'options.maxAuthAge')\n  isOptionString(jti, 'options.jti')\n  isOptionString(clockTolerance, 'options.clockTolerance')\n  isOptionString(typ, 'options.typ')\n\n  if (issuer !== undefined && (isNotString(issuer) && isNotArrayOfStrings(issuer))) {\n    throw new TypeError('options.issuer must be a string or an array of strings')\n  }\n\n  if (audience !== undefined && (isNotString(audience) && isNotArrayOfStrings(audience))) {\n    throw new TypeError('options.audience must be a string or an array of strings')\n  }\n\n  if (algorithms !== undefined && isNotArrayOfStrings(algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings')\n  }\n\n  isOptionString(nonce, 'options.nonce')\n\n  if (!(now instanceof Date) || !now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n\n  if (ignoreIat && maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together')\n  }\n\n  if (crit !== undefined && isNotArrayOfStrings(crit)) {\n    throw new TypeError('options.crit must be an array of strings')\n  }\n\n  switch (profile) {\n    case IDTOKEN:\n      if (!issuer) {\n        throw new TypeError('\"issuer\" option is required to validate an ID Token')\n      }\n\n      if (!audience) {\n        throw new TypeError('\"audience\" option is required to validate an ID Token')\n      }\n\n      break\n    case ATJWT:\n      if (!issuer) {\n        throw new TypeError('\"issuer\" option is required to validate a JWT Access Token')\n      }\n\n      if (!audience) {\n        throw new TypeError('\"audience\" option is required to validate a JWT Access Token')\n      }\n\n      typ = ATJWT\n\n      break\n    case LOGOUTTOKEN:\n      if (!issuer) {\n        throw new TypeError('\"issuer\" option is required to validate a Logout Token')\n      }\n\n      if (!audience) {\n        throw new TypeError('\"audience\" option is required to validate a Logout Token')\n      }\n\n      break\n    case undefined:\n      break\n    default:\n      throw new TypeError(`unsupported options.profile value \"${profile}\"`)\n  }\n\n  return {\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxAuthAge,\n    maxTokenAge,\n    nonce,\n    now,\n    profile,\n    subject,\n    typ\n  }\n}\n\nconst validateTypes = ({ header, payload }, profile, options) => {\n  isPayloadString(header.alg, '\"alg\" header parameter', 'alg', true)\n\n  isTimestamp(payload.iat, 'iat', profile === IDTOKEN || profile === LOGOUTTOKEN || profile === ATJWT || !!options.maxTokenAge)\n  isTimestamp(payload.exp, 'exp', profile === IDTOKEN || profile === ATJWT)\n  isTimestamp(payload.auth_time, 'auth_time', !!options.maxAuthAge)\n  isTimestamp(payload.nbf, 'nbf')\n  isPayloadString(payload.jti, '\"jti\" claim', 'jti', profile === LOGOUTTOKEN || profile === ATJWT || !!options.jti)\n  isPayloadString(payload.acr, '\"acr\" claim', 'acr')\n  isPayloadString(payload.nonce, '\"nonce\" claim', 'nonce', !!options.nonce)\n  isStringOrArrayOfStrings(payload.iss, 'iss', !!options.issuer)\n  isPayloadString(payload.sub, '\"sub\" claim', 'sub', profile === IDTOKEN || profile === ATJWT || !!options.subject)\n  isStringOrArrayOfStrings(payload.aud, 'aud', !!options.audience)\n  isPayloadString(payload.azp, '\"azp\" claim', 'azp', profile === IDTOKEN && Array.isArray(payload.aud) && payload.aud.length > 1)\n  isStringOrArrayOfStrings(payload.amr, 'amr')\n  isPayloadString(header.typ, '\"typ\" header parameter', 'typ', !!options.typ)\n\n  if (profile === ATJWT) {\n    isPayloadString(payload.client_id, '\"client_id\" claim', 'client_id', true)\n  }\n\n  if (profile === LOGOUTTOKEN) {\n    isPayloadString(payload.sid, '\"sid\" claim', 'sid')\n\n    if (!('sid' in payload) && !('sub' in payload)) {\n      throw new JWTClaimInvalid('either \"sid\" or \"sub\" (or both) claims must be present')\n    }\n\n    if ('nonce' in payload) {\n      throw new JWTClaimInvalid('\"nonce\" claim is prohibited', 'nonce', 'prohibited')\n    }\n\n    if (!('events' in payload)) {\n      throw new JWTClaimInvalid('\"events\" claim is missing', 'events', 'missing')\n    }\n\n    if (!isObject(payload.events)) {\n      throw new JWTClaimInvalid('\"events\" claim must be an object', 'events', 'invalid')\n    }\n\n    if (!('http://schemas.openid.net/event/backchannel-logout' in payload.events)) {\n      throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim', 'events', 'invalid')\n    }\n\n    if (!isObject(payload.events['http://schemas.openid.net/event/backchannel-logout'])) {\n      throw new JWTClaimInvalid('\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object', 'events', 'invalid')\n    }\n  }\n}\n\nconst checkAudiencePresence = (audPayload, audOption, profile) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload)\n  }\n\n  // Each principal intended to process the JWT MUST\n  // identify itself with a value in the audience claim\n  audPayload = new Set(audPayload)\n  return audOption.some(Set.prototype.has.bind(audPayload))\n}\n\nmodule.exports = (token, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object')\n  }\n\n  const {\n    algorithms, audience, clockTolerance, complete, crit, ignoreExp, ignoreIat, ignoreNbf, issuer,\n    jti, maxAuthAge, maxTokenAge, nonce, now, profile, subject, typ\n  } = options = validateOptions(options)\n\n  const decoded = decode(token, { complete: true })\n  key = getKey(key, true)\n\n  if (complete) {\n    ({ key } = verify(true, 'preparsed', { decoded, token }, key, { crit, algorithms, complete: true }))\n    decoded.key = key\n  } else {\n    verify(true, 'preparsed', { decoded, token }, key, { crit, algorithms })\n  }\n\n  const unix = epoch(now)\n  validateTypes(decoded, profile, options)\n\n  if (issuer && (typeof decoded.payload.iss !== 'string' || !(typeof issuer === 'string' ? [issuer] : issuer).includes(decoded.payload.iss))) {\n    throw new JWTClaimInvalid('unexpected \"iss\" claim value', 'iss', 'check_failed')\n  }\n\n  if (nonce && decoded.payload.nonce !== nonce) {\n    throw new JWTClaimInvalid('unexpected \"nonce\" claim value', 'nonce', 'check_failed')\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('unexpected \"sub\" claim value', 'sub', 'check_failed')\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('unexpected \"jti\" claim value', 'jti', 'check_failed')\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience, profile)) {\n    throw new JWTClaimInvalid('unexpected \"aud\" claim value', 'aud', 'check_failed')\n  }\n\n  if (typ && normalizeTyp(decoded.header.typ) !== normalizeTyp(typ)) {\n    throw new JWTClaimInvalid('unexpected \"typ\" JWT header value', 'typ', 'check_failed')\n  }\n\n  const tolerance = clockTolerance ? secs(clockTolerance) : 0\n\n  if (maxAuthAge) {\n    const maxAuthAgeSeconds = secs(maxAuthAge)\n    if (decoded.payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n      throw new JWTClaimInvalid('\"auth_time\" claim timestamp check failed (too much time has elapsed since the last End-User authentication)', 'auth_time', 'check_failed')\n    }\n  }\n\n  if (!ignoreIat && !('exp' in decoded.payload) && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed')\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed')\n  }\n\n  if (maxTokenAge) {\n    const age = unix - decoded.payload.iat\n    const max = secs(maxTokenAge)\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed')\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimInvalid('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')\n    }\n  }\n\n  if (profile === IDTOKEN && Array.isArray(decoded.payload.aud) && decoded.payload.aud.length > 1 && decoded.payload.azp !== audience) {\n    throw new JWTClaimInvalid('unexpected \"azp\" claim value', 'azp', 'check_failed')\n  }\n\n  return complete ? decoded : decoded.payload\n}\n"]},"metadata":{},"sourceType":"script"}