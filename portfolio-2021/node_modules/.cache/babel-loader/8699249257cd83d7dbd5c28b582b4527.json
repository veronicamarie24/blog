{"ast":null,"code":"/* eslint-disable max-classes-per-file */\nconst {\n  inspect,\n  deprecate\n} = require('util');\n\nconst url = require('url');\n\nconst jose = require('jose');\n\nconst pAny = require('p-any');\n\nconst LRU = require('lru-cache');\n\nconst objectHash = require('object-hash');\n\nconst {\n  RPError\n} = require('./errors');\n\nconst getClient = require('./client');\n\nconst registry = require('./issuer_registry');\n\nconst processResponse = require('./helpers/process_response');\n\nconst webfingerNormalize = require('./helpers/webfinger_normalize');\n\nconst instance = require('./helpers/weak_cache');\n\nconst request = require('./helpers/request');\n\nconst {\n  assertIssuerConfiguration\n} = require('./helpers/assert');\n\nconst {\n  ISSUER_DEFAULTS,\n  OIDC_DISCOVERY,\n  OAUTH2_DISCOVERY,\n  WEBFINGER,\n  REL,\n  AAD_MULTITENANT_DISCOVERY\n} = require('./helpers/consts');\n\nconst AAD_MULTITENANT = Symbol('AAD_MULTITENANT');\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n    ['introspection', 'revocation'].forEach(endpoint => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n        }\n\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n    Object.entries(meta).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).get('metadata').get(key);\n          },\n\n          enumerable: true\n        });\n      }\n    });\n    instance(this).set('cache', new LRU({\n      max: 100\n    }));\n    registry.set(this.issuer, this);\n    Object.defineProperty(this, 'Client', {\n      value: getClient(this, aadIssValidation)\n    });\n    Object.defineProperty(this, 'FAPIClient', {\n      value: class FAPIClient extends this.Client {}\n    });\n  }\n  /**\n   * @name keystore\n   * @api public\n   */\n\n\n  async keystore(reload = false) {\n    assertIssuerConfiguration(this, 'jwks_uri');\n    const keystore = instance(this).get('keystore');\n    const cache = instance(this).get('cache');\n\n    if (reload || !keystore) {\n      cache.reset();\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: this.jwks_uri\n      });\n      const jwks = processResponse(response);\n      const joseKeyStore = jose.JWKS.asKeyStore(jwks, {\n        ignoreErrors: true\n      });\n      cache.set('throttle', true, 60 * 1000);\n      instance(this).set('keystore', joseKeyStore);\n      return joseKeyStore;\n    }\n\n    return keystore;\n  }\n  /**\n   * @name queryKeyStore\n   * @api private\n   */\n\n\n  async queryKeyStore({\n    kid,\n    kty,\n    alg,\n    use,\n    key_ops: ops\n  }, {\n    allowMulti = false\n  } = {}) {\n    const cache = instance(this).get('cache');\n    const def = {\n      kid,\n      kty,\n      alg,\n      use,\n      key_ops: ops\n    };\n    const defHash = objectHash(def, {\n      algorithm: 'sha256',\n      ignoreUnknown: true,\n      unorderedArrays: true,\n      unorderedSets: true\n    }); // refresh keystore on every unknown key but also only upto once every minute\n\n    const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n    const keystore = await this.keystore(!freshJwksUri);\n    const keys = keystore.all(def);\n\n    if (keys.length === 0) {\n      throw new RPError({\n        printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n        jwks: keystore\n      });\n    }\n\n    if (!allowMulti && keys.length > 1 && !kid) {\n      throw new RPError({\n        printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n        jwks: keystore\n      });\n    }\n\n    cache.set(defHash, true);\n    return new jose.JWKS.KeyStore(keys);\n  }\n  /**\n   * @name metadata\n   * @api public\n   */\n\n\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n  /**\n   * @name webfinger\n   * @api public\n   */\n\n\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const {\n      host\n    } = url.parse(resource);\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      json: true,\n      query: {\n        resource,\n        rel: REL\n      },\n      followRedirect: true\n    });\n    const body = processResponse(response);\n    const location = Array.isArray(body.links) && body.links.find(link => typeof link === 'object' && link.rel === REL && link.href);\n\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body\n      });\n    }\n\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body\n      });\n    }\n\n    const expectedIssuer = location.href;\n\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n\n    const issuer = await this.discover(expectedIssuer);\n\n    if (issuer.issuer !== expectedIssuer) {\n      registry.delete(issuer.issuer);\n      throw new RPError('discovered issuer mismatch, expected %s, got: %s', expectedIssuer, issuer.issuer);\n    }\n\n    return issuer;\n  }\n  /**\n   * @name discover\n   * @api public\n   */\n\n\n  static async discover(uri) {\n    const parsed = url.parse(uri);\n\n    if (parsed.pathname.includes('/.well-known/')) {\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: uri\n      });\n      const body = processResponse(response);\n      return new Issuer({ ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(uri)\n      });\n    }\n\n    const uris = [];\n\n    if (parsed.pathname === '/') {\n      uris.push(`${OAUTH2_DISCOVERY}`);\n    } else {\n      uris.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`);\n    }\n\n    if (parsed.pathname.endsWith('/')) {\n      uris.push(`${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`);\n    } else {\n      uris.push(`${parsed.pathname}${OIDC_DISCOVERY}`);\n    }\n\n    return pAny(uris.map(async pathname => {\n      const wellKnownUri = url.format({ ...parsed,\n        pathname\n      });\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: wellKnownUri\n      });\n      const body = processResponse(response);\n      return new Issuer({ ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(wellKnownUri)\n      });\n    }));\n  }\n  /* istanbul ignore next */\n\n\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`;\n  }\n\n}\n/**\n * @name key\n * @api private\n */\n\n\nIssuer.prototype.key = deprecate(async function key({\n  kid,\n  kty,\n  alg,\n  use,\n  key_ops: ops\n}, allowMulti = false) {\n  const cache = instance(this).get('cache');\n  const def = {\n    kid,\n    kty,\n    alg,\n    use,\n    key_ops: ops\n  };\n  const defHash = objectHash(def, {\n    algorithm: 'sha256',\n    ignoreUnknown: true,\n    unorderedArrays: true,\n    unorderedSets: true\n  }); // refresh keystore on every unknown key but also only upto once every minute\n\n  const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n  const keystore = await this.keystore(!freshJwksUri);\n  const keys = keystore.all(def);\n\n  if (keys.length === 0) {\n    throw new RPError({\n      printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n      jwks: keystore\n    });\n  }\n\n  if (!allowMulti) {\n    if (keys.length !== 1) {\n      throw new RPError({\n        printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n        jwks: keystore\n      });\n    }\n\n    cache.set(defHash, true);\n  }\n\n  return keys[0];\n}, 'issuer.key is not only a private API, it is also deprecated');\nmodule.exports = Issuer;","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/openid-client/lib/issuer.js"],"names":["inspect","deprecate","require","url","jose","pAny","LRU","objectHash","RPError","getClient","registry","processResponse","webfingerNormalize","instance","request","assertIssuerConfiguration","ISSUER_DEFAULTS","OIDC_DISCOVERY","OAUTH2_DISCOVERY","WEBFINGER","REL","AAD_MULTITENANT_DISCOVERY","AAD_MULTITENANT","Symbol","Issuer","constructor","meta","aadIssValidation","forEach","endpoint","undefined","token_endpoint_auth_methods_supported","token_endpoint_auth_signing_alg_values_supported","Object","entries","key","value","get","set","defineProperty","enumerable","max","issuer","FAPIClient","Client","keystore","reload","cache","reset","response","call","method","json","jwks_uri","jwks","joseKeyStore","JWKS","asKeyStore","ignoreErrors","queryKeyStore","kid","kty","alg","use","key_ops","ops","allowMulti","def","defHash","algorithm","ignoreUnknown","unorderedArrays","unorderedSets","freshJwksUri","keys","all","length","printf","KeyStore","metadata","copy","webfinger","input","resource","host","parse","webfingerUrl","query","rel","followRedirect","body","location","Array","isArray","links","find","link","href","message","startsWith","expectedIssuer","has","discover","delete","uri","parsed","pathname","includes","uris","push","endsWith","substring","map","wellKnownUri","format","custom","name","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","prototype","module","exports"],"mappings":"AAAA;AAEA,MAAM;AAAEA,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAyBC,OAAO,CAAC,MAAD,CAAtC;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAnB;;AAEA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,OAAD,CAApB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,WAAD,CAAnB;;AACA,MAAMK,UAAU,GAAGL,OAAO,CAAC,aAAD,CAA1B;;AAEA,MAAM;AAAEM,EAAAA;AAAF,IAAcN,OAAO,CAAC,UAAD,CAA3B;;AACA,MAAMO,SAAS,GAAGP,OAAO,CAAC,UAAD,CAAzB;;AACA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAMS,eAAe,GAAGT,OAAO,CAAC,4BAAD,CAA/B;;AACA,MAAMU,kBAAkB,GAAGV,OAAO,CAAC,+BAAD,CAAlC;;AACA,MAAMW,QAAQ,GAAGX,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMY,OAAO,GAAGZ,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAM;AAAEa,EAAAA;AAAF,IAAgCb,OAAO,CAAC,kBAAD,CAA7C;;AACA,MAAM;AACJc,EAAAA,eADI;AACaC,EAAAA,cADb;AAC6BC,EAAAA,gBAD7B;AAC+CC,EAAAA,SAD/C;AAC0DC,EAAAA,GAD1D;AAC+DC,EAAAA;AAD/D,IAEFnB,OAAO,CAAC,kBAAD,CAFX;;AAIA,MAAMoB,eAAe,GAAGC,MAAM,CAAC,iBAAD,CAA9B;;AAEA,MAAMC,MAAN,CAAa;AACX;AACF;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,IAAI,GAAG,EAAR,EAAY;AACrB,UAAMC,gBAAgB,GAAGD,IAAI,CAACJ,eAAD,CAA7B;AACA,WAAOI,IAAI,CAACJ,eAAD,CAAX;AAEA,KAAC,eAAD,EAAkB,YAAlB,EAAgCM,OAAhC,CAAyCC,QAAD,IAAc;AACpD;AACA;AACA,UACEH,IAAI,CAAE,GAAEG,QAAS,WAAb,CAAJ,IACGH,IAAI,CAAE,GAAEG,QAAS,kCAAb,CAAJ,KAAwDC,SAD3D,IAEGJ,IAAI,CAAE,GAAEG,QAAS,6CAAb,CAAJ,KAAmEC,SAHxE,EAIE;AACA,YAAIJ,IAAI,CAACK,qCAAT,EAAgD;AAC9CL,UAAAA,IAAI,CAAE,GAAEG,QAAS,kCAAb,CAAJ,GAAsDH,IAAI,CAACK,qCAA3D;AACD;;AACD,YAAIL,IAAI,CAACM,gDAAT,EAA2D;AACzDN,UAAAA,IAAI,CAAE,GAAEG,QAAS,6CAAb,CAAJ,GAAiEH,IAAI,CAACM,gDAAtE;AACD;AACF;AACF,KAfD;AAiBAC,IAAAA,MAAM,CAACC,OAAP,CAAeR,IAAf,EAAqBE,OAArB,CAA6B,CAAC,CAACO,GAAD,EAAMC,KAAN,CAAD,KAAkB;AAC7CvB,MAAAA,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,UAAnB,EAA+BC,GAA/B,CAAmCH,GAAnC,EAAwCC,KAAxC;;AACA,UAAI,CAAC,KAAKD,GAAL,CAAL,EAAgB;AACdF,QAAAA,MAAM,CAACM,cAAP,CAAsB,IAAtB,EAA4BJ,GAA5B,EAAiC;AAC/BE,UAAAA,GAAG,GAAG;AAAE,mBAAOxB,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,UAAnB,EAA+BA,GAA/B,CAAmCF,GAAnC,CAAP;AAAiD,WAD1B;;AAE/BK,UAAAA,UAAU,EAAE;AAFmB,SAAjC;AAID;AACF,KARD;AAUA3B,IAAAA,QAAQ,CAAC,IAAD,CAAR,CAAeyB,GAAf,CAAmB,OAAnB,EAA4B,IAAIhC,GAAJ,CAAQ;AAAEmC,MAAAA,GAAG,EAAE;AAAP,KAAR,CAA5B;AAEA/B,IAAAA,QAAQ,CAAC4B,GAAT,CAAa,KAAKI,MAAlB,EAA0B,IAA1B;AAEAT,IAAAA,MAAM,CAACM,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;AACpCH,MAAAA,KAAK,EAAE3B,SAAS,CAAC,IAAD,EAAOkB,gBAAP;AADoB,KAAtC;AAIAM,IAAAA,MAAM,CAACM,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;AACxCH,MAAAA,KAAK,EAAE,MAAMO,UAAN,SAAyB,KAAKC,MAA9B,CAAqC;AADJ,KAA1C;AAGD;AAED;AACF;AACA;AACA;;;AACgB,QAARC,QAAQ,CAACC,MAAM,GAAG,KAAV,EAAiB;AAC7B/B,IAAAA,yBAAyB,CAAC,IAAD,EAAO,UAAP,CAAzB;AAEA,UAAM8B,QAAQ,GAAGhC,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,UAAnB,CAAjB;AACA,UAAMU,KAAK,GAAGlC,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,OAAnB,CAAd;;AAEA,QAAIS,MAAM,IAAI,CAACD,QAAf,EAAyB;AACvBE,MAAAA,KAAK,CAACC,KAAN;AACA,YAAMC,QAAQ,GAAG,MAAMnC,OAAO,CAACoC,IAAR,CAAa,IAAb,EAAmB;AACxCC,QAAAA,MAAM,EAAE,KADgC;AAExCC,QAAAA,IAAI,EAAE,IAFkC;AAGxCjD,QAAAA,GAAG,EAAE,KAAKkD;AAH8B,OAAnB,CAAvB;AAKA,YAAMC,IAAI,GAAG3C,eAAe,CAACsC,QAAD,CAA5B;AAEA,YAAMM,YAAY,GAAGnD,IAAI,CAACoD,IAAL,CAAUC,UAAV,CAAqBH,IAArB,EAA2B;AAAEI,QAAAA,YAAY,EAAE;AAAhB,OAA3B,CAArB;AACAX,MAAAA,KAAK,CAACT,GAAN,CAAU,UAAV,EAAsB,IAAtB,EAA4B,KAAK,IAAjC;AACAzB,MAAAA,QAAQ,CAAC,IAAD,CAAR,CAAeyB,GAAf,CAAmB,UAAnB,EAA+BiB,YAA/B;AACA,aAAOA,YAAP;AACD;;AAED,WAAOV,QAAP;AACD;AAED;AACF;AACA;AACA;;;AACqB,QAAbc,aAAa,CAAC;AAClBC,IAAAA,GADkB;AACbC,IAAAA,GADa;AACRC,IAAAA,GADQ;AACHC,IAAAA,GADG;AACEC,IAAAA,OAAO,EAAEC;AADX,GAAD,EAEhB;AAAEC,IAAAA,UAAU,GAAG;AAAf,MAAyB,EAFT,EAEa;AAC9B,UAAMnB,KAAK,GAAGlC,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,OAAnB,CAAd;AAEA,UAAM8B,GAAG,GAAG;AACVP,MAAAA,GADU;AACLC,MAAAA,GADK;AACAC,MAAAA,GADA;AACKC,MAAAA,GADL;AACUC,MAAAA,OAAO,EAAEC;AADnB,KAAZ;AAIA,UAAMG,OAAO,GAAG7D,UAAU,CAAC4D,GAAD,EAAM;AAC9BE,MAAAA,SAAS,EAAE,QADmB;AAE9BC,MAAAA,aAAa,EAAE,IAFe;AAG9BC,MAAAA,eAAe,EAAE,IAHa;AAI9BC,MAAAA,aAAa,EAAE;AAJe,KAAN,CAA1B,CAP8B,CAc9B;;AACA,UAAMC,YAAY,GAAG1B,KAAK,CAACV,GAAN,CAAU+B,OAAV,KAAsBrB,KAAK,CAACV,GAAN,CAAU,UAAV,CAA3C;AAEA,UAAMQ,QAAQ,GAAG,MAAM,KAAKA,QAAL,CAAc,CAAC4B,YAAf,CAAvB;AACA,UAAMC,IAAI,GAAG7B,QAAQ,CAAC8B,GAAT,CAAaR,GAAb,CAAb;;AAEA,QAAIO,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB;AACrB,YAAM,IAAIpE,OAAJ,CAAY;AAChBqE,QAAAA,MAAM,EAAE,CAAC,+DAAD,EAAkEV,GAAlE,CADQ;AAEhBb,QAAAA,IAAI,EAAET;AAFU,OAAZ,CAAN;AAID;;AAED,QAAI,CAACqB,UAAD,IAAeQ,IAAI,CAACE,MAAL,GAAc,CAA7B,IAAkC,CAAChB,GAAvC,EAA4C;AAC1C,YAAM,IAAIpD,OAAJ,CAAY;AAChBqE,QAAAA,MAAM,EAAE,CAAC,4GAAD,EAA+GV,GAA/G,CADQ;AAEhBb,QAAAA,IAAI,EAAET;AAFU,OAAZ,CAAN;AAID;;AAEDE,IAAAA,KAAK,CAACT,GAAN,CAAU8B,OAAV,EAAmB,IAAnB;AAEA,WAAO,IAAIhE,IAAI,CAACoD,IAAL,CAAUsB,QAAd,CAAuBJ,IAAvB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACc,MAARK,QAAQ,GAAG;AACb,UAAMC,IAAI,GAAG,EAAb;AACAnE,IAAAA,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,UAAnB,EAA+BT,OAA/B,CAAuC,CAACQ,KAAD,EAAQD,GAAR,KAAgB;AACrD6C,MAAAA,IAAI,CAAC7C,GAAD,CAAJ,GAAYC,KAAZ;AACD,KAFD;AAGA,WAAO4C,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACwB,eAATC,SAAS,CAACC,KAAD,EAAQ;AAC5B,UAAMC,QAAQ,GAAGvE,kBAAkB,CAACsE,KAAD,CAAnC;AACA,UAAM;AAAEE,MAAAA;AAAF,QAAWjF,GAAG,CAACkF,KAAJ,CAAUF,QAAV,CAAjB;AACA,UAAMG,YAAY,GAAI,WAAUF,IAAK,GAAEjE,SAAU,EAAjD;AAEA,UAAM8B,QAAQ,GAAG,MAAMnC,OAAO,CAACoC,IAAR,CAAa,IAAb,EAAmB;AACxCC,MAAAA,MAAM,EAAE,KADgC;AAExChD,MAAAA,GAAG,EAAEmF,YAFmC;AAGxClC,MAAAA,IAAI,EAAE,IAHkC;AAIxCmC,MAAAA,KAAK,EAAE;AAAEJ,QAAAA,QAAF;AAAYK,QAAAA,GAAG,EAAEpE;AAAjB,OAJiC;AAKxCqE,MAAAA,cAAc,EAAE;AALwB,KAAnB,CAAvB;AAOA,UAAMC,IAAI,GAAG/E,eAAe,CAACsC,QAAD,CAA5B;AAEA,UAAM0C,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcH,IAAI,CAACI,KAAnB,KAA6BJ,IAAI,CAACI,KAAL,CAAWC,IAAX,CAAiBC,IAAD,IAAU,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACR,GAAL,KAAapE,GAAzC,IAAgD4E,IAAI,CAACC,IAA/E,CAA9C;;AAEA,QAAI,CAACN,QAAL,EAAe;AACb,YAAM,IAAInF,OAAJ,CAAY;AAChB0F,QAAAA,OAAO,EAAE,uCADO;AAEhBR,QAAAA;AAFgB,OAAZ,CAAN;AAID;;AAED,QAAI,OAAOC,QAAQ,CAACM,IAAhB,KAAyB,QAAzB,IAAqC,CAACN,QAAQ,CAACM,IAAT,CAAcE,UAAd,CAAyB,UAAzB,CAA1C,EAAgF;AAC9E,YAAM,IAAI3F,OAAJ,CAAY;AAChBqE,QAAAA,MAAM,EAAE,CAAC,4BAAD,EAA+Bc,QAAQ,CAACM,IAAxC,CADQ;AAEhBP,QAAAA;AAFgB,OAAZ,CAAN;AAID;;AAED,UAAMU,cAAc,GAAGT,QAAQ,CAACM,IAAhC;;AACA,QAAIvF,QAAQ,CAAC2F,GAAT,CAAaD,cAAb,CAAJ,EAAkC;AAChC,aAAO1F,QAAQ,CAAC2B,GAAT,CAAa+D,cAAb,CAAP;AACD;;AAED,UAAM1D,MAAM,GAAG,MAAM,KAAK4D,QAAL,CAAcF,cAAd,CAArB;;AAEA,QAAI1D,MAAM,CAACA,MAAP,KAAkB0D,cAAtB,EAAsC;AACpC1F,MAAAA,QAAQ,CAAC6F,MAAT,CAAgB7D,MAAM,CAACA,MAAvB;AACA,YAAM,IAAIlC,OAAJ,CAAY,kDAAZ,EAAgE4F,cAAhE,EAAgF1D,MAAM,CAACA,MAAvF,CAAN;AACD;;AACD,WAAOA,MAAP;AACD;AAED;AACF;AACA;AACA;;;AACuB,eAAR4D,QAAQ,CAACE,GAAD,EAAM;AACzB,UAAMC,MAAM,GAAGtG,GAAG,CAACkF,KAAJ,CAAUmB,GAAV,CAAf;;AAEA,QAAIC,MAAM,CAACC,QAAP,CAAgBC,QAAhB,CAAyB,eAAzB,CAAJ,EAA+C;AAC7C,YAAM1D,QAAQ,GAAG,MAAMnC,OAAO,CAACoC,IAAR,CAAa,IAAb,EAAmB;AACxCC,QAAAA,MAAM,EAAE,KADgC;AAExCC,QAAAA,IAAI,EAAE,IAFkC;AAGxCjD,QAAAA,GAAG,EAAEqG;AAHmC,OAAnB,CAAvB;AAKA,YAAMd,IAAI,GAAG/E,eAAe,CAACsC,QAAD,CAA5B;AACA,aAAO,IAAIzB,MAAJ,CAAW,EAChB,GAAGR,eADa;AAEhB,WAAG0E,IAFa;AAGhB,SAACpE,eAAD,GAAmBD,yBAAyB,CAACgF,GAA1B,CAA8BG,GAA9B;AAHH,OAAX,CAAP;AAKD;;AAED,UAAMI,IAAI,GAAG,EAAb;;AACA,QAAIH,MAAM,CAACC,QAAP,KAAoB,GAAxB,EAA6B;AAC3BE,MAAAA,IAAI,CAACC,IAAL,CAAW,GAAE3F,gBAAiB,EAA9B;AACD,KAFD,MAEO;AACL0F,MAAAA,IAAI,CAACC,IAAL,CAAW,GAAE3F,gBAAiB,GAAEuF,MAAM,CAACC,QAAS,EAAhD;AACD;;AACD,QAAID,MAAM,CAACC,QAAP,CAAgBI,QAAhB,CAAyB,GAAzB,CAAJ,EAAmC;AACjCF,MAAAA,IAAI,CAACC,IAAL,CAAW,GAAEJ,MAAM,CAACC,QAAS,GAAEzF,cAAc,CAAC8F,SAAf,CAAyB,CAAzB,CAA4B,EAA3D;AACD,KAFD,MAEO;AACLH,MAAAA,IAAI,CAACC,IAAL,CAAW,GAAEJ,MAAM,CAACC,QAAS,GAAEzF,cAAe,EAA9C;AACD;;AAED,WAAOZ,IAAI,CAACuG,IAAI,CAACI,GAAL,CAAS,MAAON,QAAP,IAAoB;AACvC,YAAMO,YAAY,GAAG9G,GAAG,CAAC+G,MAAJ,CAAW,EAAE,GAAGT,MAAL;AAAaC,QAAAA;AAAb,OAAX,CAArB;AACA,YAAMzD,QAAQ,GAAG,MAAMnC,OAAO,CAACoC,IAAR,CAAa,IAAb,EAAmB;AACxCC,QAAAA,MAAM,EAAE,KADgC;AAExCC,QAAAA,IAAI,EAAE,IAFkC;AAGxCjD,QAAAA,GAAG,EAAE8G;AAHmC,OAAnB,CAAvB;AAKA,YAAMvB,IAAI,GAAG/E,eAAe,CAACsC,QAAD,CAA5B;AACA,aAAO,IAAIzB,MAAJ,CAAW,EAChB,GAAGR,eADa;AAEhB,WAAG0E,IAFa;AAGhB,SAACpE,eAAD,GAAmBD,yBAAyB,CAACgF,GAA1B,CAA8BY,YAA9B;AAHH,OAAX,CAAP;AAKD,KAbW,CAAD,CAAX;AAcD;AAED;;;AACe,GAAdjH,OAAO,CAACmH,MAAM,IAAI;AACjB,WAAQ,GAAE,KAAK1F,WAAL,CAAiB2F,IAAK,IAAGpH,OAAO,CAAC,KAAK+E,QAAN,EAAgB;AACxDsC,MAAAA,KAAK,EAAEC,QADiD;AAExDC,MAAAA,MAAM,EAAEC,OAAO,CAACC,MAAR,CAAeC,KAFiC;AAGxDC,MAAAA,OAAO,EAAE,KAH+C;AAIxDC,MAAAA,MAAM,EAAE;AAJgD,KAAhB,CAKvC,EALH;AAMD;;AA/OU;AAkPb;AACA;AACA;AACA;;;AACApG,MAAM,CAACqG,SAAP,CAAiB1F,GAAjB,GAAuBlC,SAAS,CAAC,eAAekC,GAAf,CAAmB;AAClDyB,EAAAA,GADkD;AAC7CC,EAAAA,GAD6C;AACxCC,EAAAA,GADwC;AACnCC,EAAAA,GADmC;AAC9BC,EAAAA,OAAO,EAAEC;AADqB,CAAnB,EAE9BC,UAAU,GAAG,KAFiB,EAEV;AACrB,QAAMnB,KAAK,GAAGlC,QAAQ,CAAC,IAAD,CAAR,CAAewB,GAAf,CAAmB,OAAnB,CAAd;AAEA,QAAM8B,GAAG,GAAG;AACVP,IAAAA,GADU;AACLC,IAAAA,GADK;AACAC,IAAAA,GADA;AACKC,IAAAA,GADL;AACUC,IAAAA,OAAO,EAAEC;AADnB,GAAZ;AAIA,QAAMG,OAAO,GAAG7D,UAAU,CAAC4D,GAAD,EAAM;AAC9BE,IAAAA,SAAS,EAAE,QADmB;AAE9BC,IAAAA,aAAa,EAAE,IAFe;AAG9BC,IAAAA,eAAe,EAAE,IAHa;AAI9BC,IAAAA,aAAa,EAAE;AAJe,GAAN,CAA1B,CAPqB,CAcrB;;AACA,QAAMC,YAAY,GAAG1B,KAAK,CAACV,GAAN,CAAU+B,OAAV,KAAsBrB,KAAK,CAACV,GAAN,CAAU,UAAV,CAA3C;AAEA,QAAMQ,QAAQ,GAAG,MAAM,KAAKA,QAAL,CAAc,CAAC4B,YAAf,CAAvB;AACA,QAAMC,IAAI,GAAG7B,QAAQ,CAAC8B,GAAT,CAAaR,GAAb,CAAb;;AAEA,MAAIO,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIpE,OAAJ,CAAY;AAChBqE,MAAAA,MAAM,EAAE,CAAC,+DAAD,EAAkEV,GAAlE,CADQ;AAEhBb,MAAAA,IAAI,EAAET;AAFU,KAAZ,CAAN;AAID;;AACD,MAAI,CAACqB,UAAL,EAAiB;AACf,QAAIQ,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB;AACrB,YAAM,IAAIpE,OAAJ,CAAY;AAChBqE,QAAAA,MAAM,EAAE,CAAC,4GAAD,EAA+GV,GAA/G,CADQ;AAEhBb,QAAAA,IAAI,EAAET;AAFU,OAAZ,CAAN;AAID;;AACDE,IAAAA,KAAK,CAACT,GAAN,CAAU8B,OAAV,EAAmB,IAAnB;AACD;;AACD,SAAOM,IAAI,CAAC,CAAD,CAAX;AACD,CAtC+B,EAsC7B,6DAtC6B,CAAhC;AAwCAoD,MAAM,CAACC,OAAP,GAAiBvG,MAAjB","sourcesContent":["/* eslint-disable max-classes-per-file */\n\nconst { inspect, deprecate } = require('util');\nconst url = require('url');\n\nconst jose = require('jose');\nconst pAny = require('p-any');\nconst LRU = require('lru-cache');\nconst objectHash = require('object-hash');\n\nconst { RPError } = require('./errors');\nconst getClient = require('./client');\nconst registry = require('./issuer_registry');\nconst processResponse = require('./helpers/process_response');\nconst webfingerNormalize = require('./helpers/webfinger_normalize');\nconst instance = require('./helpers/weak_cache');\nconst request = require('./helpers/request');\nconst { assertIssuerConfiguration } = require('./helpers/assert');\nconst {\n  ISSUER_DEFAULTS, OIDC_DISCOVERY, OAUTH2_DISCOVERY, WEBFINGER, REL, AAD_MULTITENANT_DISCOVERY,\n} = require('./helpers/consts');\n\nconst AAD_MULTITENANT = Symbol('AAD_MULTITENANT');\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (\n        meta[`${endpoint}_endpoint`]\n        && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined\n        && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined\n      ) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n        }\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n\n    Object.entries(meta).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).get('metadata').get(key); },\n          enumerable: true,\n        });\n      }\n    });\n\n    instance(this).set('cache', new LRU({ max: 100 }));\n\n    registry.set(this.issuer, this);\n\n    Object.defineProperty(this, 'Client', {\n      value: getClient(this, aadIssValidation),\n    });\n\n    Object.defineProperty(this, 'FAPIClient', {\n      value: class FAPIClient extends this.Client {},\n    });\n  }\n\n  /**\n   * @name keystore\n   * @api public\n   */\n  async keystore(reload = false) {\n    assertIssuerConfiguration(this, 'jwks_uri');\n\n    const keystore = instance(this).get('keystore');\n    const cache = instance(this).get('cache');\n\n    if (reload || !keystore) {\n      cache.reset();\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: this.jwks_uri,\n      });\n      const jwks = processResponse(response);\n\n      const joseKeyStore = jose.JWKS.asKeyStore(jwks, { ignoreErrors: true });\n      cache.set('throttle', true, 60 * 1000);\n      instance(this).set('keystore', joseKeyStore);\n      return joseKeyStore;\n    }\n\n    return keystore;\n  }\n\n  /**\n   * @name queryKeyStore\n   * @api private\n   */\n  async queryKeyStore({\n    kid, kty, alg, use, key_ops: ops,\n  }, { allowMulti = false } = {}) {\n    const cache = instance(this).get('cache');\n\n    const def = {\n      kid, kty, alg, use, key_ops: ops,\n    };\n\n    const defHash = objectHash(def, {\n      algorithm: 'sha256',\n      ignoreUnknown: true,\n      unorderedArrays: true,\n      unorderedSets: true,\n    });\n\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n\n    const keystore = await this.keystore(!freshJwksUri);\n    const keys = keystore.all(def);\n\n    if (keys.length === 0) {\n      throw new RPError({\n        printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n        jwks: keystore,\n      });\n    }\n\n    if (!allowMulti && keys.length > 1 && !kid) {\n      throw new RPError({\n        printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n        jwks: keystore,\n      });\n    }\n\n    cache.set(defHash, true);\n\n    return new jose.JWKS.KeyStore(keys);\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n\n  /**\n   * @name webfinger\n   * @api public\n   */\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const { host } = url.parse(resource);\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      json: true,\n      query: { resource, rel: REL },\n      followRedirect: true,\n    });\n    const body = processResponse(response);\n\n    const location = Array.isArray(body.links) && body.links.find((link) => typeof link === 'object' && link.rel === REL && link.href);\n\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body,\n      });\n    }\n\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body,\n      });\n    }\n\n    const expectedIssuer = location.href;\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n\n    const issuer = await this.discover(expectedIssuer);\n\n    if (issuer.issuer !== expectedIssuer) {\n      registry.delete(issuer.issuer);\n      throw new RPError('discovered issuer mismatch, expected %s, got: %s', expectedIssuer, issuer.issuer);\n    }\n    return issuer;\n  }\n\n  /**\n   * @name discover\n   * @api public\n   */\n  static async discover(uri) {\n    const parsed = url.parse(uri);\n\n    if (parsed.pathname.includes('/.well-known/')) {\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: uri,\n      });\n      const body = processResponse(response);\n      return new Issuer({\n        ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(uri),\n      });\n    }\n\n    const uris = [];\n    if (parsed.pathname === '/') {\n      uris.push(`${OAUTH2_DISCOVERY}`);\n    } else {\n      uris.push(`${OAUTH2_DISCOVERY}${parsed.pathname}`);\n    }\n    if (parsed.pathname.endsWith('/')) {\n      uris.push(`${parsed.pathname}${OIDC_DISCOVERY.substring(1)}`);\n    } else {\n      uris.push(`${parsed.pathname}${OIDC_DISCOVERY}`);\n    }\n\n    return pAny(uris.map(async (pathname) => {\n      const wellKnownUri = url.format({ ...parsed, pathname });\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: wellKnownUri,\n      });\n      const body = processResponse(response);\n      return new Issuer({\n        ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(wellKnownUri),\n      });\n    }));\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n}\n\n/**\n * @name key\n * @api private\n */\nIssuer.prototype.key = deprecate(async function key({\n  kid, kty, alg, use, key_ops: ops,\n}, allowMulti = false) {\n  const cache = instance(this).get('cache');\n\n  const def = {\n    kid, kty, alg, use, key_ops: ops,\n  };\n\n  const defHash = objectHash(def, {\n    algorithm: 'sha256',\n    ignoreUnknown: true,\n    unorderedArrays: true,\n    unorderedSets: true,\n  });\n\n  // refresh keystore on every unknown key but also only upto once every minute\n  const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n\n  const keystore = await this.keystore(!freshJwksUri);\n  const keys = keystore.all(def);\n\n  if (keys.length === 0) {\n    throw new RPError({\n      printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n      jwks: keystore,\n    });\n  }\n  if (!allowMulti) {\n    if (keys.length !== 1) {\n      throw new RPError({\n        printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n        jwks: keystore,\n      });\n    }\n    cache.set(defHash, true);\n  }\n  return keys[0];\n}, 'issuer.key is not only a private API, it is also deprecated');\n\nmodule.exports = Issuer;\n"]},"metadata":{},"sourceType":"script"}