{"ast":null,"code":"const {\n  STATUS_CODES\n} = require('http');\n\nconst {\n  format\n} = require('util');\n\nconst {\n  OPError\n} = require('../errors');\n\nconst REGEXP = /(\\w+)=(\"[^\"]*\")/g;\n\nconst throwAuthenticateErrors = response => {\n  const params = {};\n\n  try {\n    while (REGEXP.exec(response.headers['www-authenticate']) !== null) {\n      if (RegExp.$1 && RegExp.$2) {\n        params[RegExp.$1] = RegExp.$2.slice(1, -1);\n      }\n    }\n  } catch (err) {}\n\n  if (params.error) {\n    throw new OPError(params, response);\n  }\n};\n\nconst isStandardBodyError = response => {\n  let result = false;\n\n  try {\n    let jsonbody;\n\n    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {\n      jsonbody = JSON.parse(response.body);\n    } else {\n      jsonbody = response.body;\n    }\n\n    result = typeof jsonbody.error === 'string' && jsonbody.error.length;\n    if (result) response.body = jsonbody;\n  } catch (err) {}\n\n  return result;\n};\n\nfunction processResponse(response, {\n  statusCode = 200,\n  body = true,\n  bearer = false\n} = {}) {\n  if (response.statusCode !== statusCode) {\n    if (bearer) {\n      throwAuthenticateErrors(response);\n    }\n\n    if (isStandardBodyError(response)) {\n      throw new OPError(response.body, response);\n    }\n\n    throw new OPError({\n      error: format('expected %i %s, got: %i %s', statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])\n    }, response);\n  }\n\n  if (body && !response.body) {\n    throw new OPError({\n      error: format('expected %i %s with body but no body was returned', statusCode, STATUS_CODES[statusCode])\n    }, response);\n  }\n\n  return response.body;\n}\n\nmodule.exports = processResponse;","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/openid-client/lib/helpers/process_response.js"],"names":["STATUS_CODES","require","format","OPError","REGEXP","throwAuthenticateErrors","response","params","exec","headers","RegExp","$1","$2","slice","err","error","isStandardBodyError","result","jsonbody","body","Buffer","isBuffer","JSON","parse","length","processResponse","statusCode","bearer","module","exports"],"mappings":"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","sourcesContent":["const { STATUS_CODES } = require('http');\nconst { format } = require('util');\n\nconst { OPError } = require('../errors');\n\nconst REGEXP = /(\\w+)=(\"[^\"]*\")/g;\nconst throwAuthenticateErrors = (response) => {\n  const params = {};\n  try {\n    while ((REGEXP.exec(response.headers['www-authenticate'])) !== null) {\n      if (RegExp.$1 && RegExp.$2) {\n        params[RegExp.$1] = RegExp.$2.slice(1, -1);\n      }\n    }\n  } catch (err) {}\n\n  if (params.error) {\n    throw new OPError(params, response);\n  }\n};\n\nconst isStandardBodyError = (response) => {\n  let result = false;\n  try {\n    let jsonbody;\n    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {\n      jsonbody = JSON.parse(response.body);\n    } else {\n      jsonbody = response.body;\n    }\n    result = typeof jsonbody.error === 'string' && jsonbody.error.length;\n    if (result) response.body = jsonbody;\n  } catch (err) {}\n\n  return result;\n};\n\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n  if (response.statusCode !== statusCode) {\n    if (bearer) {\n      throwAuthenticateErrors(response);\n    }\n\n    if (isStandardBodyError(response)) {\n      throw new OPError(response.body, response);\n    }\n\n    throw new OPError({\n      error: format('expected %i %s, got: %i %s', statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode]),\n    }, response);\n  }\n\n  if (body && !response.body) {\n    throw new OPError({\n      error: format('expected %i %s with body but no body was returned', statusCode, STATUS_CODES[statusCode]),\n    }, response);\n  }\n\n  return response.body;\n}\n\n\nmodule.exports = processResponse;\n"]},"metadata":{},"sourceType":"script"}