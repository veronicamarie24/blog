{"ast":null,"code":"const {\n  strict: assert\n} = require('assert');\n\nconst {\n  createHash\n} = require('crypto');\n\nconst {\n  format\n} = require('util');\n\nconst shake256 = require('./shake256');\n\nlet encode;\n\nif (Buffer.isEncoding('base64url')) {\n  encode = input => input.toString('base64url');\n} else {\n  const fromBase64 = base64 => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n\n  encode = input => fromBase64(input.toString('base64'));\n}\n/** SPECIFICATION\n * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of\n * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm\n * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is\n * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode\n * them. The _hash value is a case sensitive string.\n */\n\n/**\n * @name getHash\n * @api private\n *\n * returns the sha length based off the JOSE alg heade value, defaults to sha256\n *\n * @param token {String} token value to generate the hash from\n * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)\n * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA\n */\n\n\nfunction getHash(alg, crv) {\n  switch (alg) {\n    case 'HS256':\n    case 'RS256':\n    case 'PS256':\n    case 'ES256':\n    case 'ES256K':\n      return createHash('sha256');\n\n    case 'HS384':\n    case 'RS384':\n    case 'PS384':\n    case 'ES384':\n      return createHash('sha384');\n\n    case 'HS512':\n    case 'RS512':\n    case 'PS512':\n    case 'ES512':\n      return createHash('sha512');\n\n    case 'EdDSA':\n      switch (crv) {\n        case 'Ed25519':\n          return createHash('sha512');\n\n        case 'Ed448':\n          if (!shake256) {\n            throw new TypeError('Ed448 *_hash calculation is not supported in your Node.js runtime version');\n          }\n\n          return createHash('shake256', {\n            outputLength: 114\n          });\n\n        default:\n          throw new TypeError('unrecognized or invalid EdDSA curve provided');\n      }\n\n    default:\n      throw new TypeError('unrecognized or invalid JWS algorithm provided');\n  }\n}\n\nfunction generate(token, alg, crv) {\n  const digest = getHash(alg, crv).update(token).digest();\n  return encode(digest.slice(0, digest.length / 2));\n}\n\nfunction validate(names, actual, source, alg, crv) {\n  if (typeof names.claim !== 'string' || !names.claim) {\n    throw new TypeError('names.claim must be a non-empty string');\n  }\n\n  if (typeof names.source !== 'string' || !names.source) {\n    throw new TypeError('names.source must be a non-empty string');\n  }\n\n  assert(typeof actual === 'string' && actual, `${names.claim} must be a non-empty string`);\n  assert(typeof source === 'string' && source, `${names.source} must be a non-empty string`);\n  let expected;\n  let msg;\n\n  try {\n    expected = generate(source, alg, crv);\n  } catch (err) {\n    msg = format('%s could not be validated (%s)', names.claim, err.message);\n  }\n\n  msg = msg || format('%s mismatch, expected %s, got: %s', names.claim, expected, actual);\n  assert.equal(expected, actual, msg);\n}\n\nmodule.exports = {\n  validate,\n  generate\n};","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/oidc-token-hash/lib/index.js"],"names":["strict","assert","require","createHash","format","shake256","encode","Buffer","isEncoding","input","toString","fromBase64","base64","replace","getHash","alg","crv","TypeError","outputLength","generate","token","digest","update","slice","length","validate","names","actual","source","claim","expected","msg","err","message","equal","module","exports"],"mappings":"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","sourcesContent":["const { strict: assert } = require('assert');\nconst { createHash } = require('crypto');\nconst { format } = require('util');\n\nconst shake256 = require('./shake256');\n\nlet encode;\nif (Buffer.isEncoding('base64url')) {\n  encode = (input) => input.toString('base64url');\n} else {\n  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n  encode = (input) => fromBase64(input.toString('base64'));\n}\n\n/** SPECIFICATION\n * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of\n * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm\n * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is\n * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode\n * them. The _hash value is a case sensitive string.\n */\n\n/**\n * @name getHash\n * @api private\n *\n * returns the sha length based off the JOSE alg heade value, defaults to sha256\n *\n * @param token {String} token value to generate the hash from\n * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)\n * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA\n */\nfunction getHash(alg, crv) {\n  switch (alg) {\n    case 'HS256':\n    case 'RS256':\n    case 'PS256':\n    case 'ES256':\n    case 'ES256K':\n      return createHash('sha256');\n\n    case 'HS384':\n    case 'RS384':\n    case 'PS384':\n    case 'ES384':\n      return createHash('sha384');\n\n    case 'HS512':\n    case 'RS512':\n    case 'PS512':\n    case 'ES512':\n      return createHash('sha512');\n\n    case 'EdDSA':\n      switch (crv) {\n        case 'Ed25519':\n          return createHash('sha512');\n        case 'Ed448':\n          if (!shake256) {\n            throw new TypeError('Ed448 *_hash calculation is not supported in your Node.js runtime version');\n          }\n\n          return createHash('shake256', { outputLength: 114 });\n        default:\n          throw new TypeError('unrecognized or invalid EdDSA curve provided');\n      }\n\n    default:\n      throw new TypeError('unrecognized or invalid JWS algorithm provided');\n  }\n}\n\nfunction generate(token, alg, crv) {\n  const digest = getHash(alg, crv).update(token).digest();\n  return encode(digest.slice(0, digest.length / 2));\n}\n\nfunction validate(names, actual, source, alg, crv) {\n  if (typeof names.claim !== 'string' || !names.claim) {\n    throw new TypeError('names.claim must be a non-empty string');\n  }\n\n  if (typeof names.source !== 'string' || !names.source) {\n    throw new TypeError('names.source must be a non-empty string');\n  }\n\n  assert(typeof actual === 'string' && actual, `${names.claim} must be a non-empty string`);\n  assert(typeof source === 'string' && source, `${names.source} must be a non-empty string`);\n\n  let expected;\n  let msg;\n  try {\n    expected = generate(source, alg, crv);\n  } catch (err) {\n    msg = format('%s could not be validated (%s)', names.claim, err.message);\n  }\n\n  msg = msg || format('%s mismatch, expected %s, got: %s', names.claim, expected, actual);\n\n  assert.equal(expected, actual, msg);\n}\n\nmodule.exports = {\n  validate,\n  generate,\n};\n"]},"metadata":{},"sourceType":"script"}