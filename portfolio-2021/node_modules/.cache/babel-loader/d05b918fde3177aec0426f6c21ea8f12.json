{"ast":null,"code":"/* eslint-disable max-classes-per-file */\nconst {\n  inspect,\n  deprecate\n} = require('util');\n\nconst stdhttp = require('http');\n\nconst crypto = require('crypto');\n\nconst {\n  strict: assert\n} = require('assert');\n\nconst querystring = require('querystring');\n\nconst url = require('url');\n\nconst {\n  ParseError\n} = require('got');\n\nconst jose = require('jose');\n\nconst base64url = require('base64url');\n\nconst defaultsDeep = require('lodash/defaultsDeep');\n\nconst defaults = require('lodash/defaults');\n\nconst merge = require('lodash/merge');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst tokenHash = require('oidc-token-hash');\n\nconst {\n  assertSigningAlgValuesSupport,\n  assertIssuerConfiguration\n} = require('./helpers/assert');\n\nconst pick = require('./helpers/pick');\n\nconst processResponse = require('./helpers/process_response');\n\nconst TokenSet = require('./token_set');\n\nconst {\n  OPError,\n  RPError\n} = require('./errors');\n\nconst now = require('./helpers/unix_timestamp');\n\nconst {\n  random\n} = require('./helpers/generators');\n\nconst request = require('./helpers/request');\n\nconst {\n  CALLBACK_PROPERTIES,\n  CLIENT_DEFAULTS,\n  JWT_CONTENT,\n  CLOCK_TOLERANCE\n} = require('./helpers/consts');\n\nconst issuerRegistry = require('./issuer_registry');\n\nconst instance = require('./helpers/weak_cache');\n\nconst {\n  authenticatedPost,\n  resolveResponseType,\n  resolveRedirectUri\n} = require('./helpers/client');\n\nconst DeviceFlowHandle = require('./device_flow_handle');\n\nfunction pickCb(input) {\n  return pick(input, ...CALLBACK_PROPERTIES);\n}\n\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return `${tokenType} ${token}`;\n}\n\nfunction cleanUpClaims(claims) {\n  if (Object.keys(claims._claim_names).length === 0) {\n    delete claims._claim_names;\n  }\n\n  if (Object.keys(claims._claim_sources).length === 0) {\n    delete claims._claim_sources;\n  }\n}\n\nfunction assignClaim(target, source, sourceName, throwOnMissing = true) {\n  return ([claim, inSource]) => {\n    if (inSource === sourceName) {\n      if (throwOnMissing && source[claim] === undefined) {\n        throw new RPError(`expected claim \"${claim}\" in \"${sourceName}\"`);\n      } else if (source[claim] !== undefined) {\n        target[claim] = source[claim];\n      }\n\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt\n    });\n  }\n}\n\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params\n  };\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n  return authParams;\n}\n\nasync function claimJWT(label, jwt) {\n  try {\n    const {\n      header,\n      payload\n    } = jose.JWT.decode(jwt, {\n      complete: true\n    });\n    const {\n      iss\n    } = payload;\n\n    if (header.alg === 'none') {\n      return payload;\n    }\n\n    let key;\n\n    if (!iss || iss === this.issuer.issuer) {\n      key = await this.issuer.queryKeyStore(header);\n    } else if (issuerRegistry.has(iss)) {\n      key = await issuerRegistry.get(iss).queryKeyStore(header);\n    } else {\n      const discovered = await this.issuer.constructor.discover(iss);\n      key = await discovered.queryKeyStore(header);\n    }\n\n    return jose.JWT.verify(jwt, key);\n  } catch (err) {\n    if (err instanceof RPError || err instanceof OPError || err.name === 'AggregateError') {\n      throw err;\n    } else {\n      throw new RPError({\n        printf: ['failed to validate the %s JWT (%s: %s)', label, err.name, err.message],\n        jwt\n      });\n    }\n  }\n}\n\nfunction getKeystore(jwks) {\n  const keystore = jose.JWKS.asKeyStore(jwks);\n\n  if (keystore.all().some(key => key.type !== 'private')) {\n    throw new TypeError('jwks must only contain private keys');\n  }\n\n  return keystore;\n} // if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\n\n\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) {\n    // if no explicit value was provided\n    checkBasicSupport(client, metadata, properties);\n  } // :fp: c'mon people... RTFM\n\n\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nclass BaseClient {}\n\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, jwks) {\n    super();\n\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n\n    const properties = { ...CLIENT_DEFAULTS,\n      ...metadata\n    };\n    handleCommonMistakes(this, metadata, properties);\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach(endpoint => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n    Object.entries(properties).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).get('metadata').get(key);\n          },\n\n          enumerable: true\n        });\n      }\n    });\n\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      instance(this).set('keystore', keystore);\n    }\n\n    this[CLOCK_TOLERANCE] = 0;\n  }\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n\n\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = { ...target.query,\n      ...authorizationParams.call(this, params)\n    };\n    return url.format(target);\n  }\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n\n\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs).map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n\n\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n    const {\n      0: postLogout,\n      length\n    } = this.post_logout_redirect_uris || [];\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined\n    } = params;\n    let hint = params.id_token_hint;\n\n    if (hint instanceof TokenSet) {\n      if (!hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n\n      hint = hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = { ...params,\n      ...target.query,\n      ...{\n        post_logout_redirect_uri,\n        id_token_hint: hint\n      }\n    };\n    Object.entries(target.query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n    return url.format(target);\n  }\n  /**\n   * @name callbackParams\n   * @api public\n   */\n\n\n  callbackParams(input) {\n    // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n    const isString = typeof input === 'string';\n\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    }\n\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n          }\n\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n\n              return pickCb(input.body);\n\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n  /**\n   * @name callback\n   * @api public\n   */\n\n\n  async callback(redirectUri, parameters, checks = {}, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type']\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant({ ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload\n      });\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n\n\n  async oauthCallback(redirectUri, parameters, checks = {}, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type']\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      return this.grant({ ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload\n      });\n    }\n\n    return new TokenSet(params);\n  }\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n\n\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n\n    return result;\n  }\n\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n    return this.validateJWT(body, expectedAlg, []);\n  }\n  /**\n   * @name decryptJARM\n   * @api private\n   */\n\n\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n  /**\n   * @name validateJARM\n   * @api private\n   */\n\n\n  async validateJARM(response) {\n    const expectedAlg = this.authorization_signed_response_alg;\n    const {\n      payload\n    } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n    return pickCb(payload);\n  }\n  /**\n   * @name decryptJWTUserinfo\n   * @api private\n   */\n\n\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n  /**\n   * @name decryptJWE\n   * @api private\n   */\n\n\n  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe\n      });\n    }\n\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe\n      });\n    }\n\n    let keyOrStore;\n\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      keyOrStore = instance(this).get('keystore');\n    } else {\n      keyOrStore = await this.joseSecret(expectedAlg === 'dir' ? expectedEnc : expectedAlg);\n    }\n\n    const payload = jose.JWE.decrypt(jwe, keyOrStore);\n    return payload.toString('utf8');\n  }\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n\n\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n    const expectedAlg = this.id_token_signed_response_alg;\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n    const timestamp = now();\n    const {\n      protected: header,\n      payload,\n      key\n    } = await this.validateJWT(idToken, expectedAlg);\n\n    if (maxAge || maxAge !== null && this.require_auth_time) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken\n        });\n      }\n\n      if (!Number.isInteger(payload.auth_time)) {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON number integer',\n          jwt: idToken\n        });\n      }\n    }\n\n    if (maxAge && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n      throw new RPError({\n        printf: ['too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i', maxAge, payload.auth_time, timestamp - this[CLOCK_TOLERANCE]],\n        jwt: idToken\n      });\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken\n      });\n    }\n\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken\n        });\n      }\n\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken\n        });\n      }\n\n      const fapi = this.constructor.name === 'FAPIClient';\n\n      if (fapi) {\n        if (payload.iat < timestamp - 3600) {\n          throw new RPError({\n            printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n            jwt: idToken\n          });\n        }\n\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken\n          });\n        }\n      }\n\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n\n        try {\n          tokenHash.validate({\n            claim: 's_hash',\n            source: 'state'\n          }, payload.s_hash, state, header.alg, key && key.crv);\n        } catch (err) {\n          throw new RPError({\n            message: err.message,\n            jwt: idToken\n          });\n        }\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'at_hash',\n          source: 'access_token'\n        }, payload.at_hash, tokenSet.access_token, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'c_hash',\n          source: 'code'\n        }, payload.c_hash, tokenSet.code, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n\n    return tokenSet;\n  }\n  /**\n   * @name validateJWT\n   * @api private\n   */\n\n\n  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n\n    try {\n      ({\n        header,\n        payload\n      } = jose.JWT.decode(jwt, {\n        complete: true\n      }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt\n      });\n    }\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt\n      });\n    }\n\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk']; // eslint-disable-line no-param-reassign\n    }\n\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n\n      if (aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt\n        });\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      if (!Number.isInteger(payload.iat)) {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON number integer',\n          jwt\n        });\n      }\n    }\n\n    if (payload.nbf !== undefined) {\n      if (!Number.isInteger(payload.nbf)) {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON number integer',\n          jwt\n        });\n      }\n\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['JWT not active yet, now %i, nbf %i', timestamp + this[CLOCK_TOLERANCE], payload.nbf],\n          jwt\n        });\n      }\n    }\n\n    if (payload.exp !== undefined) {\n      if (!Number.isInteger(payload.exp)) {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON number integer',\n          jwt\n        });\n      }\n\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          jwt\n        });\n      }\n    }\n\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt\n          });\n        }\n\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: ['aud is missing the client_id, expected %s to be included in %j', this.client_id, payload.aud],\n            jwt\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt\n        });\n      }\n    }\n\n    if (payload.azp !== undefined && payload.azp !== this.client_id) {\n      throw new RPError({\n        printf: ['azp must be the client_id, expected %s, got: %s', this.client_id, payload.azp],\n        jwt\n      });\n    }\n\n    let key;\n\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        key = jose.JWK.asKey(payload.sub_jwk);\n        assert.equal(key.type, 'public');\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt\n        });\n      }\n\n      if (key.thumbprint !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      key = await this.joseSecret();\n    } else if (header.alg !== 'none') {\n      key = await this.issuer.queryKeyStore(header);\n    }\n\n    if (!key && header.alg === 'none') {\n      return {\n        protected: header,\n        payload\n      };\n    }\n\n    try {\n      return jose.JWS.verify(jwt, key, {\n        complete: true\n      });\n    } catch (err) {\n      throw new RPError({\n        message: 'failed to validate JWT signature',\n        jwt\n      });\n    }\n  }\n  /**\n   * @name refresh\n   * @api public\n   */\n\n\n  async refresh(refreshToken, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n\n      token = token.refresh_token;\n    }\n\n    const tokenset = await this.grant({ ...exchangeBody,\n      grant_type: 'refresh_token',\n      refresh_token: String(token)\n    }, {\n      clientAssertionPayload\n    });\n\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, null, 'token', null);\n    }\n\n    return tokenset;\n  }\n\n  async requestResource(resourceUrl, accessToken, {\n    method,\n    headers,\n    body,\n    tokenType = accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer'\n  } = {}) {\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n\n      accessToken = accessToken.access_token; // eslint-disable-line no-param-reassign\n    }\n\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers\n      },\n      body\n    };\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    return request.call(this, { ...requestOpts,\n      encoding: null,\n      method,\n      url: resourceUrl\n    }, {\n      mTLS\n    });\n  }\n  /**\n   * @name userinfo\n   * @api public\n   */\n\n\n  async userinfo(accessToken, {\n    verb = 'GET',\n    via = 'header',\n    tokenType,\n    params\n  } = {}) {\n    // TODO: in v4.x remove verb in favour of method\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(verb).toUpperCase()\n    };\n\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() verb can only be POST or a GET');\n    }\n\n    if (via === 'query' && options.method !== 'GET') {\n      throw new TypeError('userinfo endpoints will only parse query strings for GET requests');\n    } else if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n\n    if (jwt) {\n      options.headers = {\n        Accept: 'application/jwt'\n      };\n    } else {\n      options.headers = {\n        Accept: 'application/json'\n      };\n    }\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n\n    targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint); // when via is not header we clear the Authorization header and add either\n    // query string parameters or urlencoded body access_token parameter\n\n    if (via === 'query') {\n      options.headers.Authorization = undefined;\n      targetUrl.searchParams.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    } else if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new url.URLSearchParams();\n      options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    } // handle additional parameters, GET via querystring, POST via urlencoded body\n\n\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(([key, value]) => {\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) {\n        // POST && via body\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      } else {\n        // POST && via header\n        options.body = new url.URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      }\n    }\n\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n\n    const response = await this.requestResource(targetUrl, accessToken, options);\n    let parsed = processResponse(response, {\n      bearer: true\n    });\n\n    if (jwt) {\n      if (!JWT_CONTENT.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response\n        });\n      }\n\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo\n          });\n        }\n      } else {\n        ({\n          payload: parsed\n        } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (error) {\n        const parseError = new ParseError(error, response.statusCode, response.request.gotOptions, response.body);\n        Object.defineProperty(parseError, 'response', {\n          value: response\n        });\n        throw parseError;\n      }\n    }\n\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token\n        });\n      }\n    }\n\n    return parsed;\n  }\n  /**\n   * @name derivedKey\n   * @api private\n   */\n\n\n  async derivedKey(len) {\n    const cacheKey = `${len}_key`;\n\n    if (instance(this).has(cacheKey)) {\n      return instance(this).get(cacheKey);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256').update(this.client_secret).digest().slice(0, len / 8);\n    const key = jose.JWK.asKey({\n      k: base64url.encode(derivedBuffer),\n      kty: 'oct'\n    });\n    instance(this).set(cacheKey, key);\n    return key;\n  }\n  /**\n   * @name joseSecret\n   * @api private\n   */\n\n\n  async joseSecret(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n\n    if (instance(this).has('jose_secret')) {\n      return instance(this).get('jose_secret');\n    }\n\n    const key = jose.JWK.asKey({\n      k: base64url.encode(this.client_secret),\n      kty: 'oct'\n    });\n    instance(this).set('jose_secret', key);\n    return key;\n  }\n  /**\n   * @name grant\n   * @api public\n   */\n\n\n  async grant(body, {\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(this, 'token', {\n      form: true,\n      body,\n      json: true\n    }, {\n      clientAssertionPayload\n    });\n    const responseBody = processResponse(response);\n    return new TokenSet(responseBody);\n  }\n  /**\n   * @name deviceAuthorization\n   * @api public\n   */\n\n\n  async deviceAuthorization(params = {}, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params\n    });\n    const response = await authenticatedPost.call(this, 'device_authorization', {\n      form: true,\n      body,\n      json: true\n    }, {\n      clientAssertionPayload,\n      endpointAuthMethod: 'token'\n    });\n    const responseBody = processResponse(response);\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age\n    });\n  }\n  /**\n   * @name revoke\n   * @api public\n   */\n\n\n  async revoke(token, hint, {\n    revokeBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const body = { ...revokeBody,\n      token\n    };\n\n    if (hint) {\n      body.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(this, 'revocation', {\n      body,\n      form: true\n    }, {\n      clientAssertionPayload\n    });\n    processResponse(response, {\n      body: false\n    });\n  }\n  /**\n   * @name introspect\n   * @api public\n   */\n\n\n  async introspect(token, hint, {\n    introspectBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const body = { ...introspectBody,\n      token\n    };\n\n    if (hint) {\n      body.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(this, 'introspection', {\n      body,\n      form: true,\n      json: true\n    }, {\n      clientAssertionPayload\n    });\n    const responseBody = processResponse(response);\n    return responseBody;\n  }\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n\n\n  async fetchDistributedClaims(claims, tokens = {}) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const distributedSources = Object.entries(claims._claim_sources).filter(([, value]) => value && value.endpoint);\n    await Promise.all(distributedSources.map(async ([sourceName, def]) => {\n      try {\n        const requestOpts = {\n          headers: {\n            Accept: 'application/jwt',\n            Authorization: authorizationHeaderValue(def.access_token || tokens[sourceName])\n          }\n        };\n        const response = await request.call(this, { ...requestOpts,\n          method: 'GET',\n          url: def.endpoint\n        });\n        const body = processResponse(response, {\n          bearer: true\n        });\n        const decoded = await claimJWT.call(this, 'distributed', body);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName, false));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n    cleanUpClaims(claims);\n    return claims;\n  }\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n\n\n  async unpackAggregatedClaims(claims) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const aggregatedSources = Object.entries(claims._claim_sources).filter(([, value]) => value && value.JWT);\n    await Promise.all(aggregatedSources.map(async ([sourceName, def]) => {\n      try {\n        const decoded = await claimJWT.call(this, 'aggregated', def.JWT);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n    cleanUpClaims(claims);\n    return claims;\n  }\n  /**\n   * @name register\n   * @api public\n   */\n\n\n  static async register(properties, {\n    initialAccessToken,\n    jwks\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (jwks !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      const keystore = getKeystore.call(this, jwks);\n      properties.jwks = keystore.toJWKS(false);\n    }\n\n    const response = await request.call(this, {\n      headers: initialAccessToken ? {\n        Authorization: authorizationHeaderValue(initialAccessToken)\n      } : undefined,\n      json: true,\n      body: properties,\n      url: this.issuer.registration_endpoint,\n      method: 'POST'\n    });\n    const responseBody = processResponse(response, {\n      statusCode: 201,\n      bearer: true\n    });\n    return new this(responseBody, jwks);\n  }\n  /**\n   * @name metadata\n   * @api public\n   */\n\n\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n  /**\n   * @name fromUri\n   * @api public\n   */\n\n\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      json: true,\n      headers: {\n        Authorization: authorizationHeaderValue(registrationAccessToken)\n      }\n    });\n    const responseBody = processResponse(response, {\n      bearer: true\n    });\n    return new this(responseBody, jwks);\n  }\n  /**\n   * @name requestObject\n   * @api public\n   */\n\n\n  async requestObject(requestObject = {}, algorithms = {}) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n\n    defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc || 'A128CBC-HS256'\n      }\n    }, {\n      sign: 'none'\n    });\n    let signed;\n    let key;\n    const alg = algorithms.sign;\n    const header = {\n      alg,\n      typ: 'JWT'\n    };\n    const payload = JSON.stringify(defaults({}, requestObject, {\n      iss: this.client_id,\n      aud: this.issuer.issuer,\n      client_id: this.client_id,\n      jti: random(),\n      iat: now(),\n      exp: now() + 300\n    }));\n\n    if (alg === 'none') {\n      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');\n    } else {\n      const symmetric = alg.startsWith('HS');\n\n      if (symmetric) {\n        key = await this.joseSecret();\n      } else {\n        const keystore = instance(this).get('keystore');\n\n        if (!keystore) {\n          throw new TypeError(`no keystore present for client, cannot sign using alg ${alg}`);\n        }\n\n        key = keystore.get({\n          alg,\n          use: 'sig'\n        });\n\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${alg}`);\n        }\n      }\n\n      signed = jose.JWS.sign(payload, key, { ...header,\n        kid: symmetric ? undefined : key.kid\n      });\n    }\n\n    if (!algorithms.encrypt.alg) {\n      return signed;\n    }\n\n    const fields = {\n      alg: algorithms.encrypt.alg,\n      enc: algorithms.encrypt.enc,\n      cty: 'JWT'\n    };\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await this.issuer.queryKeyStore({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc'\n      }, {\n        allowMulti: true\n      });\n    } else {\n      key = await this.joseSecret(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n\n    return jose.JWE.encrypt(signed, key, { ...fields,\n      kid: key.kty === 'oct' ? undefined : key.kid\n    });\n  }\n  /**\n   * @name issuer\n   * @api public\n   */\n\n\n  static get issuer() {\n    return issuer;\n  }\n  /**\n   * @name issuer\n   * @api public\n   */\n\n\n  get issuer() {\n    // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n  /* istanbul ignore next */\n\n\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    })}`;\n  }\n\n}; // TODO: remove in 4.x\n\n\nBaseClient.prototype.resource = deprecate(\n/* istanbul ignore next */\nasync function resource(resourceUrl, accessToken, options) {\n  let token = accessToken;\n  const opts = merge({\n    verb: 'GET',\n    via: 'header'\n  }, options);\n\n  if (token instanceof TokenSet) {\n    if (!token.access_token) {\n      throw new TypeError('access_token not present in TokenSet');\n    }\n\n    opts.tokenType = opts.tokenType || token.token_type;\n    token = token.access_token;\n  }\n\n  const verb = String(opts.verb).toUpperCase();\n  let requestOpts;\n\n  switch (opts.via) {\n    case 'query':\n      if (verb !== 'GET') {\n        throw new TypeError('resource servers should only parse query strings for GET requests');\n      }\n\n      requestOpts = {\n        query: {\n          access_token: token\n        }\n      };\n      break;\n\n    case 'body':\n      if (verb !== 'POST') {\n        throw new TypeError('can only send body on POST');\n      }\n\n      requestOpts = {\n        form: true,\n        body: {\n          access_token: token\n        }\n      };\n      break;\n\n    default:\n      requestOpts = {\n        headers: {\n          Authorization: authorizationHeaderValue(token, opts.tokenType)\n        }\n      };\n  }\n\n  if (opts.params) {\n    if (verb === 'POST') {\n      defaultsDeep(requestOpts, {\n        body: opts.params\n      });\n    } else {\n      defaultsDeep(requestOpts, {\n        query: opts.params\n      });\n    }\n  }\n\n  if (opts.headers) {\n    defaultsDeep(requestOpts, {\n      headers: opts.headers\n    });\n  }\n\n  const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n  return request.call(this, { ...requestOpts,\n    encoding: null,\n    method: verb,\n    url: resourceUrl\n  }, {\n    mTLS\n  });\n}, 'client.resource() is deprecated, use client.requestResource() instead, see docs for API details');\nmodule.exports.BaseClient = BaseClient;","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/openid-client/lib/client.js"],"names":["inspect","deprecate","require","stdhttp","crypto","strict","assert","querystring","url","ParseError","jose","base64url","defaultsDeep","defaults","merge","isPlainObject","tokenHash","assertSigningAlgValuesSupport","assertIssuerConfiguration","pick","processResponse","TokenSet","OPError","RPError","now","random","request","CALLBACK_PROPERTIES","CLIENT_DEFAULTS","JWT_CONTENT","CLOCK_TOLERANCE","issuerRegistry","instance","authenticatedPost","resolveResponseType","resolveRedirectUri","DeviceFlowHandle","pickCb","input","authorizationHeaderValue","token","tokenType","cleanUpClaims","claims","Object","keys","_claim_names","length","_claim_sources","assignClaim","target","source","sourceName","throwOnMissing","claim","inSource","undefined","verifyPresence","payload","jwt","prop","message","authorizationParams","params","authParams","client_id","scope","response_type","call","redirect_uri","entries","forEach","key","value","JSON","stringify","Array","isArray","String","claimJWT","label","header","JWT","decode","complete","iss","alg","issuer","queryKeyStore","has","get","discovered","constructor","discover","verify","err","name","printf","getKeystore","jwks","keystore","JWKS","asKeyStore","all","some","type","TypeError","checkBasicSupport","client","metadata","properties","supported","token_endpoint_auth_methods_supported","includes","token_endpoint_auth_method","handleCommonMistakes","redirect_uris","response_types","getDefaultsForEndpoint","endpoint","tokenEndpointAuthMethod","tokenEndpointAuthSigningAlg","token_endpoint_auth_signing_alg","eam","easa","BaseClient","module","exports","aadIssValidation","Client","set","defineProperty","enumerable","authorizationUrl","parse","authorization_endpoint","search","query","format","authorizationPost","inputs","formInputs","map","join","endSessionUrl","postLogout","post_logout_redirect_uris","post_logout_redirect_uri","hint","id_token_hint","id_token","end_session_endpoint","callbackParams","isIncomingMessage","IncomingMessage","method","isString","body","Buffer","isBuffer","toString","callback","redirectUri","parameters","checks","exchangeBody","clientAssertionPayload","jarm","decrypted","decryptJARM","response","validateJARM","default_max_age","max_age","state","error","RESPONSE_TYPE_REQUIRED_PARAMS","code","split","access_token","param","tokenset","decryptIdToken","validateIdToken","nonce","grant","grant_type","code_verifier","session_state","oauthCallback","id_token_encrypted_response_alg","idToken","expectedAlg","expectedEnc","id_token_encrypted_response_enc","result","decryptJWE","validateJWTUserinfo","userinfo_signed_response_alg","validateJWT","authorization_encrypted_response_alg","authorization_encrypted_response_enc","authorization_signed_response_alg","decryptJWTUserinfo","userinfo_encrypted_response_alg","userinfo_encrypted_response_enc","jwe","enc","keyOrStore","match","joseSecret","JWE","decrypt","tokenSet","returnedBy","maxAge","id_token_signed_response_alg","isTokenSet","timestamp","protected","require_auth_time","auth_time","Number","isInteger","at_hash","c_hash","fapi","iat","s_hash","validate","crv","required","isSelfIssued","bind","expectedIss","replace","tid","nbf","exp","aud","azp","sub_jwk","JWK","asKey","equal","thumbprint","sub","startsWith","JWS","refresh","refreshToken","refresh_token","requestResource","resourceUrl","accessToken","headers","token_type","requestOpts","Authorization","mTLS","tls_client_certificate_bound_access_tokens","encoding","userinfo","verb","via","options","toUpperCase","Accept","targetUrl","mtls_endpoint_aliases","userinfo_endpoint","URL","searchParams","append","URLSearchParams","parsed","bearer","test","parseError","statusCode","gotOptions","expectedSub","derivedKey","len","cacheKey","derivedBuffer","createHash","update","client_secret","digest","slice","k","encode","kty","parseInt","RegExp","$1","$2","form","json","responseBody","deviceAuthorization","endpointAuthMethod","revoke","revokeBody","token_type_hint","introspect","introspectBody","fetchDistributedClaims","tokens","distributedSources","filter","Promise","def","decoded","src","unpackAggregatedClaims","aggregatedSources","register","initialAccessToken","jwks_uri","toJWKS","registration_endpoint","copy","fromUri","registrationClientUri","registrationAccessToken","requestObject","algorithms","sign","request_object_signing_alg","encrypt","request_object_encryption_alg","request_object_encryption_enc","signed","typ","jti","symmetric","use","kid","fields","cty","allowMulti","custom","depth","Infinity","colors","process","stdout","isTTY","compact","sorted","prototype","resource","opts"],"mappings":"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","sourcesContent":["/* eslint-disable max-classes-per-file */\n\nconst { inspect, deprecate } = require('util');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst { strict: assert } = require('assert');\nconst querystring = require('querystring');\nconst url = require('url');\n\nconst { ParseError } = require('got');\nconst jose = require('jose');\nconst base64url = require('base64url');\nconst defaultsDeep = require('lodash/defaultsDeep');\nconst defaults = require('lodash/defaults');\nconst merge = require('lodash/merge');\nconst isPlainObject = require('lodash/isPlainObject');\nconst tokenHash = require('oidc-token-hash');\n\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = require('./helpers/assert');\nconst pick = require('./helpers/pick');\nconst processResponse = require('./helpers/process_response');\nconst TokenSet = require('./token_set');\nconst { OPError, RPError } = require('./errors');\nconst now = require('./helpers/unix_timestamp');\nconst { random } = require('./helpers/generators');\nconst request = require('./helpers/request');\nconst {\n  CALLBACK_PROPERTIES, CLIENT_DEFAULTS, JWT_CONTENT, CLOCK_TOLERANCE,\n} = require('./helpers/consts');\nconst issuerRegistry = require('./issuer_registry');\nconst instance = require('./helpers/weak_cache');\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = require('./helpers/client');\nconst DeviceFlowHandle = require('./device_flow_handle');\n\nfunction pickCb(input) {\n  return pick(input, ...CALLBACK_PROPERTIES);\n}\n\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return `${tokenType} ${token}`;\n}\n\nfunction cleanUpClaims(claims) {\n  if (Object.keys(claims._claim_names).length === 0) {\n    delete claims._claim_names;\n  }\n  if (Object.keys(claims._claim_sources).length === 0) {\n    delete claims._claim_sources;\n  }\n}\n\nfunction assignClaim(target, source, sourceName, throwOnMissing = true) {\n  return ([claim, inSource]) => {\n    if (inSource === sourceName) {\n      if (throwOnMissing && source[claim] === undefined) {\n        throw new RPError(`expected claim \"${claim}\" in \"${sourceName}\"`);\n      } else if (source[claim] !== undefined) {\n        target[claim] = source[claim];\n      }\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: `missing required JWT property ${prop}`,\n      jwt,\n    });\n  }\n}\n\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params,\n  };\n\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n\n  return authParams;\n}\n\nasync function claimJWT(label, jwt) {\n  try {\n    const { header, payload } = jose.JWT.decode(jwt, { complete: true });\n    const { iss } = payload;\n\n    if (header.alg === 'none') {\n      return payload;\n    }\n\n    let key;\n    if (!iss || iss === this.issuer.issuer) {\n      key = await this.issuer.queryKeyStore(header);\n    } else if (issuerRegistry.has(iss)) {\n      key = await issuerRegistry.get(iss).queryKeyStore(header);\n    } else {\n      const discovered = await this.issuer.constructor.discover(iss);\n      key = await discovered.queryKeyStore(header);\n    }\n    return jose.JWT.verify(jwt, key);\n  } catch (err) {\n    if (err instanceof RPError || err instanceof OPError || err.name === 'AggregateError') {\n      throw err;\n    } else {\n      throw new RPError({\n        printf: ['failed to validate the %s JWT (%s: %s)', label, err.name, err.message],\n        jwt,\n      });\n    }\n  }\n}\n\nfunction getKeystore(jwks) {\n  const keystore = jose.JWKS.asKeyStore(jwks);\n  if (keystore.all().some((key) => key.type !== 'private')) {\n    throw new TypeError('jwks must only contain private keys');\n  }\n  return keystore;\n}\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) { // if no explicit value was provided\n    checkBasicSupport(client, metadata, properties);\n  }\n\n  // :fp: c'mon people... RTFM\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[`${endpoint}_endpoint`]) return;\n\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n\n  const eam = `${endpoint}_endpoint_auth_method`;\n  const easa = `${endpoint}_endpoint_auth_signing_alg`;\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nclass BaseClient {}\n\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, jwks) {\n    super();\n\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n\n    const properties = { ...CLIENT_DEFAULTS, ...metadata };\n\n    handleCommonMistakes(this, metadata, properties);\n\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n\n    Object.entries(properties).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).get('metadata').get(key); },\n          enumerable: true,\n        });\n      }\n    });\n\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      instance(this).set('keystore', keystore);\n    }\n\n    this[CLOCK_TOLERANCE] = 0;\n  }\n\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...target.query,\n      ...authorizationParams.call(this, params),\n    };\n    return url.format(target);\n  }\n\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map((name) => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n\n    const {\n      0: postLogout,\n      length,\n    } = this.post_logout_redirect_uris || [];\n\n    const {\n      post_logout_redirect_uri = length === 1 ? postLogout : undefined,\n    } = params;\n\n    let hint = params.id_token_hint;\n\n    if (hint instanceof TokenSet) {\n      if (!hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      hint = hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = {\n      ...params,\n      ...target.query,\n      ...{\n        post_logout_redirect_uri,\n        id_token_hint: hint,\n      },\n    };\n\n    Object.entries(target.query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n\n    return url.format(target);\n  }\n\n  /**\n   * @name callbackParams\n   * @api public\n   */\n  callbackParams(input) { // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage\n      || (input && input.method && input.url);\n    const isString = typeof input === 'string';\n\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    }\n\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n          }\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n\n              return pickCb(input.body);\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n\n  /**\n   * @name callback\n   * @api public\n   */\n  async callback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) { // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) { // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      }, { clientAssertionPayload });\n\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n  async oauthCallback(\n    redirectUri,\n    parameters,\n    checks = {},\n    { exchangeBody, clientAssertionPayload } = {},\n  ) {\n    let params = pickCb(parameters);\n\n    if (checks.jarm && !('response' in parameters)) {\n      throw new RPError({\n        message: 'expected a JARM response',\n        checks,\n        params,\n      });\n    } else if ('response' in parameters) {\n      const decrypted = await this.decryptJARM(params.response);\n      params = await this.validateJARM(decrypted);\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params,\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params,\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type'],\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) { // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params,\n            });\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) { // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: `${param} missing from response`,\n                checks,\n                params,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      return this.grant({\n        ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      }, { clientAssertionPayload });\n    }\n\n    return new TokenSet(params);\n  }\n\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n  async decryptIdToken(token) {\n    if (!this.id_token_encrypted_response_alg) {\n      return token;\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this.id_token_encrypted_response_alg;\n    const expectedEnc = this.id_token_encrypted_response_enc;\n\n    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n\n    return result;\n  }\n\n  async validateJWTUserinfo(body) {\n    const expectedAlg = this.userinfo_signed_response_alg;\n\n    return this.validateJWT(body, expectedAlg, []);\n  }\n\n  /**\n   * @name decryptJARM\n   * @api private\n   */\n  async decryptJARM(response) {\n    if (!this.authorization_encrypted_response_alg) {\n      return response;\n    }\n\n    const expectedAlg = this.authorization_encrypted_response_alg;\n    const expectedEnc = this.authorization_encrypted_response_enc;\n\n    return this.decryptJWE(response, expectedAlg, expectedEnc);\n  }\n\n  /**\n   * @name validateJARM\n   * @api private\n   */\n  async validateJARM(response) {\n    const expectedAlg = this.authorization_signed_response_alg;\n    const { payload } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);\n    return pickCb(payload);\n  }\n\n  /**\n   * @name decryptJWTUserinfo\n   * @api private\n   */\n  async decryptJWTUserinfo(body) {\n    if (!this.userinfo_encrypted_response_alg) {\n      return body;\n    }\n\n    const expectedAlg = this.userinfo_encrypted_response_alg;\n    const expectedEnc = this.userinfo_encrypted_response_enc;\n\n    return this.decryptJWE(body, expectedAlg, expectedEnc);\n  }\n\n  /**\n   * @name decryptJWE\n   * @api private\n   */\n  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {\n    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: jwe,\n      });\n    }\n\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: jwe,\n      });\n    }\n\n    let keyOrStore;\n\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      keyOrStore = instance(this).get('keystore');\n    } else {\n      keyOrStore = await this.joseSecret(expectedAlg === 'dir' ? expectedEnc : expectedAlg);\n    }\n\n    const payload = jose.JWE.decrypt(jwe, keyOrStore);\n    return payload.toString('utf8');\n  }\n\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = this.id_token_signed_response_alg;\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n\n    if (maxAge || (maxAge !== null && this.require_auth_time)) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken,\n        });\n      }\n      if (!Number.isInteger(payload.auth_time)) {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON number integer',\n          jwt: idToken,\n        });\n      }\n    }\n\n    if (maxAge && (payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE])) {\n      throw new RPError({\n        printf: ['too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i', maxAge, payload.auth_time, timestamp - this[CLOCK_TOLERANCE]],\n        jwt: idToken,\n      });\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken,\n      });\n    }\n\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken,\n        });\n      }\n\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken,\n        });\n      }\n\n      const fapi = this.constructor.name === 'FAPIClient';\n\n      if (fapi) {\n        if (payload.iat < timestamp - 3600) {\n          throw new RPError({\n            printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],\n            jwt: idToken,\n          });\n        }\n\n        if (!payload.s_hash && (tokenSet.state || state)) {\n          throw new RPError({\n            message: 'missing required property s_hash',\n            jwt: idToken,\n          });\n        }\n      }\n\n\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n\n        try {\n          tokenHash.validate({ claim: 's_hash', source: 'state' }, payload.s_hash, state, header.alg, key && key.crv);\n        } catch (err) {\n          throw new RPError({ message: err.message, jwt: idToken });\n        }\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate({ claim: 'at_hash', source: 'access_token' }, payload.at_hash, tokenSet.access_token, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate({ claim: 'c_hash', source: 'code' }, payload.c_hash, tokenSet.code, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({ message: err.message, jwt: idToken });\n      }\n    }\n\n    return tokenSet;\n  }\n\n  /**\n   * @name validateJWT\n   * @api private\n   */\n  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {\n    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';\n    const timestamp = now();\n    let header;\n    let payload;\n    try {\n      ({ header, payload } = jose.JWT.decode(jwt, { complete: true }));\n    } catch (err) {\n      throw new RPError({\n        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],\n        jwt,\n      });\n    }\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt,\n      });\n    }\n\n    if (isSelfIssued) {\n      required = [...required, 'sub_jwk']; // eslint-disable-line no-param-reassign\n    }\n\n    required.forEach(verifyPresence.bind(undefined, payload, jwt));\n\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n\n      if (aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      if (!Number.isInteger(payload.iat)) {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON number integer',\n          jwt,\n        });\n      }\n    }\n\n    if (payload.nbf !== undefined) {\n      if (!Number.isInteger(payload.nbf)) {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON number integer',\n          jwt,\n        });\n      }\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['JWT not active yet, now %i, nbf %i', timestamp + this[CLOCK_TOLERANCE], payload.nbf],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.exp !== undefined) {\n      if (!Number.isInteger(payload.exp)) {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON number integer',\n          jwt,\n        });\n      }\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt,\n          });\n        }\n\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: ['aud is missing the client_id, expected %s to be included in %j', this.client_id, payload.aud],\n            jwt,\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt,\n        });\n      }\n    }\n\n    if (payload.azp !== undefined && payload.azp !== this.client_id) {\n      throw new RPError({\n        printf: ['azp must be the client_id, expected %s, got: %s', this.client_id, payload.azp],\n        jwt,\n      });\n    }\n\n    let key;\n\n    if (isSelfIssued) {\n      try {\n        assert(isPlainObject(payload.sub_jwk));\n        key = jose.JWK.asKey(payload.sub_jwk);\n        assert.equal(key.type, 'public');\n      } catch (err) {\n        throw new RPError({\n          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',\n          jwt,\n        });\n      }\n      if (key.thumbprint !== payload.sub) {\n        throw new RPError({\n          message: 'failed to match the subject with sub_jwk',\n          jwt,\n        });\n      }\n    } else if (header.alg.startsWith('HS')) {\n      key = await this.joseSecret();\n    } else if (header.alg !== 'none') {\n      key = await this.issuer.queryKeyStore(header);\n    }\n\n    if (!key && header.alg === 'none') {\n      return { protected: header, payload };\n    }\n\n    try {\n      return jose.JWS.verify(jwt, key, { complete: true });\n    } catch (err) {\n      throw new RPError({\n        message: 'failed to validate JWT signature',\n        jwt,\n      });\n    }\n  }\n\n  /**\n   * @name refresh\n   * @api public\n   */\n  async refresh(refreshToken, { exchangeBody, clientAssertionPayload } = {}) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n      token = token.refresh_token;\n    }\n\n    const tokenset = await this.grant({\n      ...exchangeBody,\n      grant_type: 'refresh_token',\n      refresh_token: String(token),\n    }, { clientAssertionPayload });\n\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, null, 'token', null);\n    }\n\n    return tokenset;\n  }\n\n  async requestResource(\n    resourceUrl,\n    accessToken,\n    {\n      method,\n      headers,\n      body,\n      tokenType = accessToken instanceof TokenSet ? accessToken.token_type : 'Bearer',\n    } = {},\n  ) {\n    if (accessToken instanceof TokenSet) {\n      if (!accessToken.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      accessToken = accessToken.access_token; // eslint-disable-line no-param-reassign\n    }\n\n    const requestOpts = {\n      headers: {\n        Authorization: authorizationHeaderValue(accessToken, tokenType),\n        ...headers,\n      },\n      body,\n    };\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    return request.call(this, {\n      ...requestOpts,\n      encoding: null,\n      method,\n      url: resourceUrl,\n    }, { mTLS });\n  }\n\n  /**\n   * @name userinfo\n   * @api public\n   */\n  async userinfo(accessToken, {\n    verb = 'GET', via = 'header', tokenType, params,\n  } = {}) {\n    // TODO: in v4.x remove verb in favour of method\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    const options = {\n      tokenType,\n      method: String(verb).toUpperCase(),\n    };\n\n    if (options.method !== 'GET' && options.method !== 'POST') {\n      throw new TypeError('#userinfo() verb can only be POST or a GET');\n    }\n\n    if (via === 'query' && options.method !== 'GET') {\n      throw new TypeError('userinfo endpoints will only parse query strings for GET requests');\n    } else if (via === 'body' && options.method !== 'POST') {\n      throw new TypeError('can only send body on POST');\n    }\n\n    const jwt = !!(this.userinfo_signed_response_alg\n      || this.userinfo_encrypted_response_alg);\n\n    if (jwt) {\n      options.headers = { Accept: 'application/jwt' };\n    } else {\n      options.headers = { Accept: 'application/json' };\n    }\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n    }\n\n    targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);\n\n    // when via is not header we clear the Authorization header and add either\n    // query string parameters or urlencoded body access_token parameter\n    if (via === 'query') {\n      options.headers.Authorization = undefined;\n      targetUrl.searchParams.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    } else if (via === 'body') {\n      options.headers.Authorization = undefined;\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.body = new url.URLSearchParams();\n      options.body.append('access_token', accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n    }\n\n    // handle additional parameters, GET via querystring, POST via urlencoded body\n    if (params) {\n      if (options.method === 'GET') {\n        Object.entries(params).forEach(([key, value]) => {\n          targetUrl.searchParams.append(key, value);\n        });\n      } else if (options.body) { // POST && via body\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      } else { // POST && via header\n        options.body = new url.URLSearchParams();\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        Object.entries(params).forEach(([key, value]) => {\n          options.body.append(key, value);\n        });\n      }\n    }\n\n    if (options.body) {\n      options.body = options.body.toString();\n    }\n\n    const response = await this.requestResource(targetUrl, accessToken, options);\n\n    let parsed = processResponse(response, { bearer: true });\n\n    if (jwt) {\n      if (!JWT_CONTENT.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response,\n        });\n      }\n\n      const body = response.body.toString();\n      const userinfo = await this.decryptJWTUserinfo(body);\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo,\n          });\n        }\n      } else {\n        ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n      }\n    } else {\n      try {\n        parsed = JSON.parse(response.body);\n      } catch (error) {\n        const parseError = new ParseError(\n          error, response.statusCode, response.request.gotOptions, response.body,\n        );\n        Object.defineProperty(parseError, 'response', { value: response });\n        throw parseError;\n      }\n    }\n\n    if (accessToken instanceof TokenSet && accessToken.id_token) {\n      const expectedSub = accessToken.claims().sub;\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token,\n        });\n      }\n    }\n\n    return parsed;\n  }\n\n  /**\n   * @name derivedKey\n   * @api private\n   */\n  async derivedKey(len) {\n    const cacheKey = `${len}_key`;\n    if (instance(this).has(cacheKey)) {\n      return instance(this).get(cacheKey);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256')\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n\n    const key = jose.JWK.asKey({ k: base64url.encode(derivedBuffer), kty: 'oct' });\n    instance(this).set(cacheKey, key);\n\n    return key;\n  }\n\n  /**\n   * @name joseSecret\n   * @api private\n   */\n  async joseSecret(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n\n    if (instance(this).has('jose_secret')) {\n      return instance(this).get('jose_secret');\n    }\n\n    const key = jose.JWK.asKey({ k: base64url.encode(this.client_secret), kty: 'oct' });\n    instance(this).set('jose_secret', key);\n\n    return key;\n  }\n\n  /**\n   * @name grant\n   * @api public\n   */\n  async grant(body, { clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(\n      this,\n      'token',\n      {\n        form: true,\n        body,\n        json: true,\n      },\n      { clientAssertionPayload },\n    );\n    const responseBody = processResponse(response);\n\n    return new TokenSet(responseBody);\n  }\n\n  /**\n   * @name deviceAuthorization\n   * @api public\n   */\n  async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params,\n    });\n\n    const response = await authenticatedPost.call(\n      this,\n      'device_authorization',\n      {\n        form: true,\n        body,\n        json: true,\n      },\n      { clientAssertionPayload, endpointAuthMethod: 'token' },\n    );\n    const responseBody = processResponse(response);\n\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age,\n    });\n  }\n\n  /**\n   * @name revoke\n   * @api public\n   */\n  async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const body = { ...revokeBody, token };\n\n    if (hint) {\n      body.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'revocation', {\n        body,\n        form: true,\n      }, { clientAssertionPayload },\n    );\n    processResponse(response, { body: false });\n  }\n\n  /**\n   * @name introspect\n   * @api public\n   */\n  async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const body = { ...introspectBody, token };\n    if (hint) {\n      body.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(\n      this,\n      'introspection',\n      { body, form: true, json: true },\n      { clientAssertionPayload },\n    );\n\n    const responseBody = processResponse(response);\n\n    return responseBody;\n  }\n\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n  async fetchDistributedClaims(claims, tokens = {}) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const distributedSources = Object.entries(claims._claim_sources)\n      .filter(([, value]) => value && value.endpoint);\n\n    await Promise.all(distributedSources.map(async ([sourceName, def]) => {\n      try {\n        const requestOpts = {\n          headers: {\n            Accept: 'application/jwt',\n            Authorization: authorizationHeaderValue(def.access_token || tokens[sourceName]),\n          },\n        };\n\n        const response = await request.call(this, {\n          ...requestOpts,\n          method: 'GET',\n          url: def.endpoint,\n        });\n        const body = processResponse(response, { bearer: true });\n\n        const decoded = await claimJWT.call(this, 'distributed', body);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(\n          assignClaim(claims, decoded, sourceName, false),\n        );\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n\n    cleanUpClaims(claims);\n    return claims;\n  }\n\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n  async unpackAggregatedClaims(claims) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const aggregatedSources = Object.entries(claims._claim_sources)\n      .filter(([, value]) => value && value.JWT);\n\n    await Promise.all(aggregatedSources.map(async ([sourceName, def]) => {\n      try {\n        const decoded = await claimJWT.call(this, 'aggregated', def.JWT);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n\n    cleanUpClaims(claims);\n    return claims;\n  }\n\n  /**\n   * @name register\n   * @api public\n   */\n  static async register(properties, { initialAccessToken, jwks } = {}) {\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (jwks !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      const keystore = getKeystore.call(this, jwks);\n      properties.jwks = keystore.toJWKS(false);\n    }\n\n    const response = await request.call(this, {\n      headers: initialAccessToken ? {\n        Authorization: authorizationHeaderValue(initialAccessToken),\n      } : undefined,\n      json: true,\n      body: properties,\n      url: this.issuer.registration_endpoint,\n      method: 'POST',\n    });\n    const responseBody = processResponse(response, { statusCode: 201, bearer: true });\n\n    return new this(responseBody, jwks);\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n\n  /**\n   * @name fromUri\n   * @api public\n   */\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      json: true,\n      headers: { Authorization: authorizationHeaderValue(registrationAccessToken) },\n    });\n    const responseBody = processResponse(response, { bearer: true });\n\n    return new this(responseBody, jwks);\n  }\n\n  /**\n   * @name requestObject\n   * @api public\n   */\n  async requestObject(requestObject = {}, algorithms = {}) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n\n    defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc || 'A128CBC-HS256',\n      },\n    }, {\n      sign: 'none',\n    });\n\n    let signed;\n    let key;\n\n    const alg = algorithms.sign;\n    const header = { alg, typ: 'JWT' };\n    const payload = JSON.stringify(defaults({}, requestObject, {\n      iss: this.client_id,\n      aud: this.issuer.issuer,\n      client_id: this.client_id,\n      jti: random(),\n      iat: now(),\n      exp: now() + 300,\n    }));\n\n    if (alg === 'none') {\n      signed = [\n        base64url.encode(JSON.stringify(header)),\n        base64url.encode(payload),\n        '',\n      ].join('.');\n    } else {\n      const symmetric = alg.startsWith('HS');\n      if (symmetric) {\n        key = await this.joseSecret();\n      } else {\n        const keystore = instance(this).get('keystore');\n\n        if (!keystore) {\n          throw new TypeError(`no keystore present for client, cannot sign using alg ${alg}`);\n        }\n        key = keystore.get({ alg, use: 'sig' });\n        if (!key) {\n          throw new TypeError(`no key to sign with found for alg ${alg}`);\n        }\n      }\n\n      signed = jose.JWS.sign(payload, key, {\n        ...header,\n        kid: symmetric ? undefined : key.kid,\n      });\n    }\n\n    if (!algorithms.encrypt.alg) {\n      return signed;\n    }\n\n    const fields = { alg: algorithms.encrypt.alg, enc: algorithms.encrypt.enc, cty: 'JWT' };\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      [key] = await this.issuer.queryKeyStore({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc',\n      }, { allowMulti: true });\n    } else {\n      key = await this.joseSecret(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n\n    return jose.JWE.encrypt(signed, key, {\n      ...fields,\n      kid: key.kty === 'oct' ? undefined : key.kid,\n    });\n  }\n\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  static get issuer() {\n    return issuer;\n  }\n\n\n  /**\n   * @name issuer\n   * @api public\n   */\n  get issuer() { // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n\n  /* istanbul ignore next */\n  [inspect.custom]() {\n    return `${this.constructor.name} ${inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true,\n    })}`;\n  }\n};\n\n// TODO: remove in 4.x\nBaseClient.prototype.resource = deprecate(\n  /* istanbul ignore next */\n  async function resource(resourceUrl, accessToken, options) {\n    let token = accessToken;\n    const opts = merge({\n      verb: 'GET',\n      via: 'header',\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n      opts.tokenType = opts.tokenType || token.token_type;\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toUpperCase();\n    let requestOpts;\n\n    switch (opts.via) {\n      case 'query':\n        if (verb !== 'GET') {\n          throw new TypeError('resource servers should only parse query strings for GET requests');\n        }\n        requestOpts = { query: { access_token: token } };\n        break;\n      case 'body':\n        if (verb !== 'POST') {\n          throw new TypeError('can only send body on POST');\n        }\n        requestOpts = { form: true, body: { access_token: token } };\n        break;\n      default:\n        requestOpts = {\n          headers: {\n            Authorization: authorizationHeaderValue(token, opts.tokenType),\n          },\n        };\n    }\n\n    if (opts.params) {\n      if (verb === 'POST') {\n        defaultsDeep(requestOpts, { body: opts.params });\n      } else {\n        defaultsDeep(requestOpts, { query: opts.params });\n      }\n    }\n\n    if (opts.headers) {\n      defaultsDeep(requestOpts, { headers: opts.headers });\n    }\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n\n    return request.call(this, {\n      ...requestOpts,\n      encoding: null,\n      method: verb,\n      url: resourceUrl,\n    }, { mTLS });\n  }, 'client.resource() is deprecated, use client.requestResource() instead, see docs for API details',\n);\n\nmodule.exports.BaseClient = BaseClient;\n"]},"metadata":{},"sourceType":"script"}