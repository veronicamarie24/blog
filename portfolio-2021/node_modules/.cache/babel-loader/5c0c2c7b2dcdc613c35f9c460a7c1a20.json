{"ast":null,"code":"const merge = require('lodash/merge');\n\nconst omitBy = require('lodash/omitBy');\n\nconst jose = require('jose');\n\nconst {\n  assertIssuerConfiguration\n} = require('./assert');\n\nconst {\n  random\n} = require('./generators');\n\nconst now = require('./unix_timestamp');\n\nconst request = require('./request');\n\nconst instance = require('./weak_cache');\n\nconst formUrlEncode = value => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n\n  if (!alg) {\n    assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n  }\n\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    const key = await this.joseSecret();\n\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg = Array.isArray(supported) && supported.find(signAlg => key.algorithms('sign').has(signAlg));\n    }\n\n    return jose.JWS.sign(payload, key, {\n      alg,\n      typ: 'JWT'\n    });\n  }\n\n  const keystore = instance(this).get('keystore');\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const algs = new Set();\n    keystore.all().forEach(key => {\n      key.algorithms('sign').forEach(Set.prototype.add.bind(algs));\n    });\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg = Array.isArray(supported) && supported.find(signAlg => algs.has(signAlg));\n  }\n\n  const key = keystore.get({\n    alg,\n    use: 'sig'\n  });\n\n  if (!key) {\n    throw new TypeError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n  }\n\n  return jose.JWS.sign(payload, key, {\n    alg,\n    typ: 'JWT',\n    kid: key.kid\n  });\n}\n\nasync function authFor(endpoint, {\n  clientAssertionPayload\n} = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return {\n        body: {\n          client_id: this.client_id\n        }\n      };\n\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_post client authentication method requires a client_secret');\n      }\n\n      return {\n        body: {\n          client_id: this.client_id,\n          client_secret: this.client_secret\n        }\n      };\n\n    case 'private_key_jwt':\n    case 'client_secret_jwt':\n      {\n        const timestamp = now();\n        const assertion = await clientAssertion.call(this, endpoint, {\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: random(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: this.issuer[`${endpoint}_endpoint`],\n          // TODO: in v4.x pass the issuer instead (for now clientAssertionPayload can be used for that)\n          ...clientAssertionPayload\n        });\n        return {\n          body: {\n            client_id: this.client_id,\n            client_assertion: assertion,\n            client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n          }\n        };\n      }\n\n    default:\n      {\n        // client_secret_basic\n        // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n        // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n        // > The client identifier is encoded using the\n        // > \"application/x-www-form-urlencoded\" encoding algorithm per\n        // > Appendix B, and the encoded value is used as the username; the client\n        // > password is encoded using the same algorithm and used as the\n        // > password.\n        if (!this.client_secret) {\n          throw new TypeError('client_secret_basic client authentication method requires a client_secret');\n        }\n\n        const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n        const value = Buffer.from(encoded).toString('base64');\n        return {\n          headers: {\n            Authorization: `Basic ${value}`\n          }\n        };\n      }\n  }\n}\n\nfunction resolveResponseType() {\n  const {\n    length,\n    0: value\n  } = this.response_types;\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const {\n    length,\n    0: value\n  } = this.redirect_uris || [];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(endpoint, opts, {\n  clientAssertionPayload,\n  endpointAuthMethod = endpoint\n} = {}) {\n  const auth = await authFor.call(this, endpointAuthMethod, {\n    clientAssertionPayload\n  });\n  const requestOpts = merge(opts, auth, {\n    form: true\n  });\n  const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') || endpoint === 'token' && this.tls_client_certificate_bound_access_tokens;\n  let targetUrl;\n\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n\n  if ('body' in requestOpts) {\n    requestOpts.body = omitBy(requestOpts.body, arg => arg === undefined);\n  }\n\n  return request.call(this, { ...requestOpts,\n    method: 'POST',\n    url: targetUrl\n  }, {\n    mTLS\n  });\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost\n};","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/openid-client/lib/helpers/client.js"],"names":["merge","require","omitBy","jose","assertIssuerConfiguration","random","now","request","instance","formUrlEncode","value","encodeURIComponent","replace","clientAssertion","endpoint","payload","alg","issuer","key","joseSecret","supported","Array","isArray","find","signAlg","algorithms","has","JWS","sign","typ","keystore","get","TypeError","algs","Set","all","forEach","prototype","add","bind","use","kid","authFor","clientAssertionPayload","authMethod","body","client_id","client_secret","timestamp","assertion","call","iat","exp","jti","iss","sub","aud","client_assertion","client_assertion_type","encoded","Buffer","from","toString","headers","Authorization","resolveResponseType","length","response_types","undefined","resolveRedirectUri","redirect_uris","authenticatedPost","opts","endpointAuthMethod","auth","requestOpts","form","mTLS","includes","tls_client_certificate_bound_access_tokens","targetUrl","mtls_endpoint_aliases","arg","method","url","module","exports"],"mappings":"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","sourcesContent":["const merge = require('lodash/merge');\nconst omitBy = require('lodash/omitBy');\nconst jose = require('jose');\n\nconst { assertIssuerConfiguration } = require('./assert');\nconst { random } = require('./generators');\nconst now = require('./unix_timestamp');\nconst request = require('./request');\nconst instance = require('./weak_cache');\n\nconst formUrlEncode = (value) => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n  if (!alg) {\n    assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n  }\n\n  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {\n    const key = await this.joseSecret();\n\n    if (!alg) {\n      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n      alg = Array.isArray(supported) && supported.find((signAlg) => key.algorithms('sign').has(signAlg));\n    }\n\n    return jose.JWS.sign(payload, key, { alg, typ: 'JWT' });\n  }\n\n  const keystore = instance(this).get('keystore');\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const algs = new Set();\n\n    keystore.all().forEach((key) => {\n      key.algorithms('sign').forEach(Set.prototype.add.bind(algs));\n    });\n\n    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n    alg = Array.isArray(supported) && supported.find((signAlg) => algs.has(signAlg));\n  }\n\n  const key = keystore.get({ alg, use: 'sig' });\n  if (!key) {\n    throw new TypeError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n  }\n  return jose.JWS.sign(payload, key, { alg, typ: 'JWT', kid: key.kid });\n}\n\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n  const authMethod = this[`${endpoint}_endpoint_auth_method`];\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return { body: { client_id: this.client_id } };\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_post client authentication method requires a client_secret');\n      }\n      return { body: { client_id: this.client_id, client_secret: this.client_secret } };\n    case 'private_key_jwt':\n    case 'client_secret_jwt': {\n      const timestamp = now();\n      const assertion = await clientAssertion.call(this, endpoint, {\n        iat: timestamp,\n        exp: timestamp + 60,\n        jti: random(),\n        iss: this.client_id,\n        sub: this.client_id,\n        aud: this.issuer[`${endpoint}_endpoint`], // TODO: in v4.x pass the issuer instead (for now clientAssertionPayload can be used for that)\n        ...clientAssertionPayload,\n      });\n\n      return {\n        body: {\n          client_id: this.client_id,\n          client_assertion: assertion,\n          client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n        },\n      };\n    }\n    default: { // client_secret_basic\n      // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n      // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n      // > The client identifier is encoded using the\n      // > \"application/x-www-form-urlencoded\" encoding algorithm per\n      // > Appendix B, and the encoded value is used as the username; the client\n      // > password is encoded using the same algorithm and used as the\n      // > password.\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_basic client authentication method requires a client_secret');\n      }\n      const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n      const value = Buffer.from(encoded).toString('base64');\n      return { headers: { Authorization: `Basic ${value}` } };\n    }\n  }\n}\n\nfunction resolveResponseType() {\n  const { length, 0: value } = this.response_types;\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const { length, 0: value } = this.redirect_uris || [];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(endpoint, opts, {\n  clientAssertionPayload, endpointAuthMethod = endpoint,\n} = {}) {\n  const auth = await authFor.call(this, endpointAuthMethod, { clientAssertionPayload });\n  const requestOpts = merge(opts, auth, { form: true });\n\n  const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth')\n    || (endpoint === 'token' && this.tls_client_certificate_bound_access_tokens);\n\n  let targetUrl;\n  if (mTLS && this.issuer.mtls_endpoint_aliases) {\n    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n  }\n\n  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n\n  if ('body' in requestOpts) {\n    requestOpts.body = omitBy(requestOpts.body, (arg) => arg === undefined);\n  }\n\n  return request.call(this, {\n    ...requestOpts,\n    method: 'POST',\n    url: targetUrl,\n  }, { mTLS });\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost,\n};\n"]},"metadata":{},"sourceType":"script"}