{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nconst url = require('url');\n\nconst {\n  format\n} = require('util');\n\nconst cloneDeep = require('lodash/cloneDeep');\n\nconst {\n  RPError,\n  OPError\n} = require('./errors');\n\nconst {\n  BaseClient\n} = require('./client');\n\nconst {\n  random,\n  codeChallenge\n} = require('./helpers/generators');\n\nconst pick = require('./helpers/pick');\n\nconst {\n  resolveResponseType,\n  resolveRedirectUri\n} = require('./helpers/client');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n/**\n * @name constructor\n * @api public\n */\n\n\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false\n} = {}, verify) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = cloneDeep(params);\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n\n    if (!Array.isArray(supportedMethods)) {\n      throw new TypeError('code_challenge_methods_supported is not properly set on issuer');\n    }\n\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new TypeError('neither supported code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n    /* start authentication request */\n\n    if (Object.keys(reqParams).length === 0) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options\n      };\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) {\n          // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n\n    const session = req.session[sessionKey];\n\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n    }\n\n    const {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options\n    };\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    };\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks);\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n    const args = [tokenset, verified.bind(this)];\n\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message: 'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset\n        });\n      }\n\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n\n    if (passReq) {\n      args.unshift(req);\n    }\n\n    this._verify(...args);\n    /* end authentication response */\n\n  })().catch(error => {\n    if (error instanceof OPError && error.error !== 'server_error' && !error.error.startsWith('invalid') || error instanceof RPError) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\n\nmodule.exports = OpenIDConnectStrategy;","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/openid-client/lib/passport_strategy.js"],"names":["url","require","format","cloneDeep","RPError","OPError","BaseClient","random","codeChallenge","pick","resolveResponseType","resolveRedirectUri","verified","err","user","info","error","fail","success","OpenIDConnectStrategy","client","params","passReqToCallback","sessionKey","usePKCE","verify","TypeError","issuer","_client","_issuer","_verify","_passReqToCallback","_usePKCE","_key","parse","hostname","_params","supportedMethods","code_challenge_methods_supported","Array","isArray","includes","name","response_type","call","redirect_uri","scope","prototype","authenticate","req","options","session","reqParams","callbackParams","Object","keys","length","state","nonce","verifier","code_verifier","code_challenge","code_challenge_method","redirect","authorizationUrl","Error","max_age","maxAge","codeVerifier","responseType","opts","checks","tokenset","callback","passReq","loadUserinfo","userinfo_endpoint","args","bind","access_token","message","userinfo","splice","unshift","catch","startsWith","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nconst url = require('url');\nconst { format } = require('util');\n\nconst cloneDeep = require('lodash/cloneDeep');\n\nconst { RPError, OPError } = require('./errors');\nconst { BaseClient } = require('./client');\nconst { random, codeChallenge } = require('./helpers/generators');\nconst pick = require('./helpers/pick');\nconst { resolveResponseType, resolveRedirectUri } = require('./helpers/client');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\n/**\n * @name constructor\n * @api public\n */\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false,\n} = {}, verify) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = cloneDeep(params);\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n    if (!Array.isArray(supportedMethods)) {\n      throw new TypeError('code_challenge_methods_supported is not properly set on issuer');\n    }\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new TypeError('neither supported code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    /* start authentication request */\n    if (Object.keys(reqParams).length === 0) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options,\n      };\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) { // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n    const session = req.session[sessionKey];\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n    }\n\n    const {\n      state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType,\n    } = session;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options,\n    };\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType,\n    };\n\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks);\n\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    const args = [tokenset, verified.bind(this)];\n\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message: 'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset,\n        });\n      }\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n\n    if (passReq) {\n      args.unshift(req);\n    }\n\n    this._verify(...args);\n    /* end authentication response */\n  })().catch((error) => {\n    if (\n      (error instanceof OPError && error.error !== 'server_error' && !error.error.startsWith('invalid'))\n      || error instanceof RPError\n    ) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\n\nmodule.exports = OpenIDConnectStrategy;\n"]},"metadata":{},"sourceType":"script"}