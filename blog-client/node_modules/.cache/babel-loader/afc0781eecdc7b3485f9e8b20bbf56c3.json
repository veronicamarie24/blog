{"ast":null,"code":"'use strict';\n\nconst AggregateError = require('aggregate-error');\n\nconst PCancelable = require('p-cancelable');\n\nconst pSome = (iterable, options) => new PCancelable((resolve, reject, onCancel) => {\n  options = {\n    filter: () => true,\n    ...options\n  };\n\n  if (!Number.isFinite(options.count)) {\n    throw new TypeError(`Expected a finite number, got ${typeof options.count}`);\n  }\n\n  const values = [];\n  const errors = [];\n  let elementCount = 0;\n  let maxErrors = -options.count + 1;\n  let maxFiltered = -options.count + 1;\n  let isDone = false;\n  const completed = new Set();\n\n  const cancelPendingIfDone = () => {\n    if (!isDone) {\n      return;\n    }\n\n    for (const promise of iterable) {\n      if (!completed.has(promise) && typeof promise.cancel === 'function') {\n        promise.cancel();\n      }\n    }\n  };\n\n  onCancel(() => {\n    isDone = true;\n    cancelPendingIfDone();\n  });\n\n  const fulfilled = value => {\n    if (isDone) {\n      return;\n    }\n\n    if (!options.filter(value)) {\n      if (--maxFiltered === 0) {\n        isDone = true;\n        reject(new RangeError('Not enough values pass the `filter` option'));\n      }\n\n      return;\n    }\n\n    values.push(value);\n\n    if (--options.count === 0) {\n      isDone = true;\n      resolve(values);\n    }\n  };\n\n  const rejected = error => {\n    if (isDone) {\n      return;\n    }\n\n    errors.push(error);\n\n    if (--maxErrors === 0) {\n      isDone = true;\n      reject(new AggregateError(errors));\n    }\n  };\n\n  for (const element of iterable) {\n    maxErrors++;\n    maxFiltered++;\n    elementCount++;\n\n    (async () => {\n      try {\n        const value = await Promise.resolve(element);\n        fulfilled(value);\n      } catch (error) {\n        rejected(error);\n      }\n\n      completed.add(element);\n      cancelPendingIfDone();\n    })();\n  }\n\n  if (options.count > elementCount) {\n    throw new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`);\n  }\n});\n\nmodule.exports = pSome; // TODO: Remove this for the next major release\n\nmodule.exports.default = pSome;\nmodule.exports.AggregateError = AggregateError;","map":{"version":3,"sources":["/Users/veronica/Documents/react-portfolio-2021/portfolio-2021/node_modules/p-some/index.js"],"names":["AggregateError","require","PCancelable","pSome","iterable","options","resolve","reject","onCancel","filter","Number","isFinite","count","TypeError","values","errors","elementCount","maxErrors","maxFiltered","isDone","completed","Set","cancelPendingIfDone","promise","has","cancel","fulfilled","value","RangeError","push","rejected","error","element","Promise","add","module","exports","default"],"mappings":"AAAA;;AACA,MAAMA,cAAc,GAAGC,OAAO,CAAC,iBAAD,CAA9B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAA3B;;AAEA,MAAME,KAAK,GAAG,CAACC,QAAD,EAAWC,OAAX,KAAuB,IAAIH,WAAJ,CAAgB,CAACI,OAAD,EAAUC,MAAV,EAAkBC,QAAlB,KAA+B;AACnFH,EAAAA,OAAO,GAAG;AACTI,IAAAA,MAAM,EAAE,MAAM,IADL;AAET,OAAGJ;AAFM,GAAV;;AAKA,MAAI,CAACK,MAAM,CAACC,QAAP,CAAgBN,OAAO,CAACO,KAAxB,CAAL,EAAqC;AACpC,UAAM,IAAIC,SAAJ,CAAe,iCAAgC,OAAOR,OAAO,CAACO,KAAM,EAApE,CAAN;AACA;;AAED,QAAME,MAAM,GAAG,EAAf;AACA,QAAMC,MAAM,GAAG,EAAf;AACA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,SAAS,GAAG,CAACZ,OAAO,CAACO,KAAT,GAAiB,CAAjC;AACA,MAAIM,WAAW,GAAG,CAACb,OAAO,CAACO,KAAT,GAAiB,CAAnC;AACA,MAAIO,MAAM,GAAG,KAAb;AAEA,QAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;;AACA,QAAMC,mBAAmB,GAAG,MAAM;AACjC,QAAI,CAACH,MAAL,EAAa;AACZ;AACA;;AAED,SAAK,MAAMI,OAAX,IAAsBnB,QAAtB,EAAgC;AAC/B,UAAI,CAACgB,SAAS,CAACI,GAAV,CAAcD,OAAd,CAAD,IAA2B,OAAOA,OAAO,CAACE,MAAf,KAA0B,UAAzD,EAAqE;AACpEF,QAAAA,OAAO,CAACE,MAAR;AACA;AACD;AACD,GAVD;;AAYAjB,EAAAA,QAAQ,CAAC,MAAM;AACdW,IAAAA,MAAM,GAAG,IAAT;AACAG,IAAAA,mBAAmB;AACnB,GAHO,CAAR;;AAKA,QAAMI,SAAS,GAAGC,KAAK,IAAI;AAC1B,QAAIR,MAAJ,EAAY;AACX;AACA;;AAED,QAAI,CAACd,OAAO,CAACI,MAAR,CAAekB,KAAf,CAAL,EAA4B;AAC3B,UAAI,EAAET,WAAF,KAAkB,CAAtB,EAAyB;AACxBC,QAAAA,MAAM,GAAG,IAAT;AACAZ,QAAAA,MAAM,CAAC,IAAIqB,UAAJ,CAAe,4CAAf,CAAD,CAAN;AACA;;AAED;AACA;;AAEDd,IAAAA,MAAM,CAACe,IAAP,CAAYF,KAAZ;;AAEA,QAAI,EAAEtB,OAAO,CAACO,KAAV,KAAoB,CAAxB,EAA2B;AAC1BO,MAAAA,MAAM,GAAG,IAAT;AACAb,MAAAA,OAAO,CAACQ,MAAD,CAAP;AACA;AACD,GApBD;;AAsBA,QAAMgB,QAAQ,GAAGC,KAAK,IAAI;AACzB,QAAIZ,MAAJ,EAAY;AACX;AACA;;AAEDJ,IAAAA,MAAM,CAACc,IAAP,CAAYE,KAAZ;;AAEA,QAAI,EAAEd,SAAF,KAAgB,CAApB,EAAuB;AACtBE,MAAAA,MAAM,GAAG,IAAT;AACAZ,MAAAA,MAAM,CAAC,IAAIP,cAAJ,CAAmBe,MAAnB,CAAD,CAAN;AACA;AACD,GAXD;;AAaA,OAAK,MAAMiB,OAAX,IAAsB5B,QAAtB,EAAgC;AAC/Ba,IAAAA,SAAS;AACTC,IAAAA,WAAW;AACXF,IAAAA,YAAY;;AAEZ,KAAC,YAAY;AACZ,UAAI;AACH,cAAMW,KAAK,GAAG,MAAMM,OAAO,CAAC3B,OAAR,CAAgB0B,OAAhB,CAApB;AACAN,QAAAA,SAAS,CAACC,KAAD,CAAT;AACA,OAHD,CAGE,OAAOI,KAAP,EAAc;AACfD,QAAAA,QAAQ,CAACC,KAAD,CAAR;AACA;;AAEDX,MAAAA,SAAS,CAACc,GAAV,CAAcF,OAAd;AACAV,MAAAA,mBAAmB;AACnB,KAVD;AAWA;;AAED,MAAIjB,OAAO,CAACO,KAAR,GAAgBI,YAApB,EAAkC;AACjC,UAAM,IAAIY,UAAJ,CAAgB,sCAAqCvB,OAAO,CAACO,KAAM,wBAAuBI,YAAa,QAAvG,CAAN;AACA;AACD,CA3FoC,CAArC;;AA6FAmB,MAAM,CAACC,OAAP,GAAiBjC,KAAjB,C,CACA;;AACAgC,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBlC,KAAzB;AAEAgC,MAAM,CAACC,OAAP,CAAepC,cAAf,GAAgCA,cAAhC","sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\nconst PCancelable = require('p-cancelable');\n\nconst pSome = (iterable, options) => new PCancelable((resolve, reject, onCancel) => {\n\toptions = {\n\t\tfilter: () => true,\n\t\t...options\n\t};\n\n\tif (!Number.isFinite(options.count)) {\n\t\tthrow new TypeError(`Expected a finite number, got ${typeof options.count}`);\n\t}\n\n\tconst values = [];\n\tconst errors = [];\n\tlet elementCount = 0;\n\tlet maxErrors = -options.count + 1;\n\tlet maxFiltered = -options.count + 1;\n\tlet isDone = false;\n\n\tconst completed = new Set();\n\tconst cancelPendingIfDone = () => {\n\t\tif (!isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const promise of iterable) {\n\t\t\tif (!completed.has(promise) && typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t}\n\t};\n\n\tonCancel(() => {\n\t\tisDone = true;\n\t\tcancelPendingIfDone();\n\t});\n\n\tconst fulfilled = value => {\n\t\tif (isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.filter(value)) {\n\t\t\tif (--maxFiltered === 0) {\n\t\t\t\tisDone = true;\n\t\t\t\treject(new RangeError('Not enough values pass the `filter` option'));\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.push(value);\n\n\t\tif (--options.count === 0) {\n\t\t\tisDone = true;\n\t\t\tresolve(values);\n\t\t}\n\t};\n\n\tconst rejected = error => {\n\t\tif (isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\terrors.push(error);\n\n\t\tif (--maxErrors === 0) {\n\t\t\tisDone = true;\n\t\t\treject(new AggregateError(errors));\n\t\t}\n\t};\n\n\tfor (const element of iterable) {\n\t\tmaxErrors++;\n\t\tmaxFiltered++;\n\t\telementCount++;\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tconst value = await Promise.resolve(element);\n\t\t\t\tfulfilled(value);\n\t\t\t} catch (error) {\n\t\t\t\trejected(error);\n\t\t\t}\n\n\t\t\tcompleted.add(element);\n\t\t\tcancelPendingIfDone();\n\t\t})();\n\t}\n\n\tif (options.count > elementCount) {\n\t\tthrow new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`);\n\t}\n});\n\nmodule.exports = pSome;\n// TODO: Remove this for the next major release\nmodule.exports.default = pSome;\n\nmodule.exports.AggregateError = AggregateError;\n"]},"metadata":{},"sourceType":"script"}